<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-corner-indicator.min.css?v=1.0.2">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="转自 公众号 大数据技术与架构 原文链接   HiveSQL常用优化方法全面总结  Hive作为大数据领域常用的数据仓库组件，在平时设计和查询时要特别注意效率。影响Hive效率的几乎从不是数据量过大，而是数据倾斜、数据冗余、job或I/O过多、MapReduce分配不合理等等。对Hive的调优既包含对HiveQL语句本身的优化，也包含Hive配置项和MR方面的调整。 列裁剪和分区裁剪最基本的操作">
<meta name="keywords" content="HIVE">
<meta property="og:type" content="article">
<meta property="og:title" content="HiveSQL常用优化方法总结">
<meta property="og:url" content="http://chenqikai.github.io/2020/06/17/HiveSQL常用优化方法总结/index.html">
<meta property="og:site_name" content="Eli&#39;blog">
<meta property="og:description" content="转自 公众号 大数据技术与架构 原文链接   HiveSQL常用优化方法全面总结  Hive作为大数据领域常用的数据仓库组件，在平时设计和查询时要特别注意效率。影响Hive效率的几乎从不是数据量过大，而是数据倾斜、数据冗余、job或I/O过多、MapReduce分配不合理等等。对Hive的调优既包含对HiveQL语句本身的优化，也包含Hive配置项和MR方面的调整。 列裁剪和分区裁剪最基本的操作">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gfv47skxb5j30bo07yq45.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gfv4767rjej30kt0b9aco.jpg">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:updated_time" content="2020-06-17T03:19:08.229Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HiveSQL常用优化方法总结">
<meta name="twitter:description" content="转自 公众号 大数据技术与架构 原文链接   HiveSQL常用优化方法全面总结  Hive作为大数据领域常用的数据仓库组件，在平时设计和查询时要特别注意效率。影响Hive效率的几乎从不是数据量过大，而是数据倾斜、数据冗余、job或I/O过多、MapReduce分配不合理等等。对Hive的调优既包含对HiveQL语句本身的优化，也包含Hive配置项和MR方面的调整。 列裁剪和分区裁剪最基本的操作">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gfv47skxb5j30bo07yq45.jpg">
  <link rel="canonical" href="http://chenqikai.github.io/2020/06/17/HiveSQL常用优化方法总结/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>HiveSQL常用优化方法总结 | Eli'blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?00dc780f8ffe07194bbae3a2dcd66e8c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eli'blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenqikai.github.io/2020/06/17/HiveSQL常用优化方法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eli'blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">HiveSQL常用优化方法总结

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-17 11:03:03" itemprop="dateCreated datePublished" datetime="2020-06-17T11:03:03+08:00">2020-06-17</time>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/HIVE/" itemprop="url" rel="index"><span itemprop="name">HIVE</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">10k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">9 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>转自 公众号 <a href="https://mp.weixin.qq.com/s?__biz=MzU3MzgwNTU2Mg==&mid=2247486054&idx=3&sn=b0aae1d5212d401d980066500c20872b&chksm=fd3d4cf3ca4ac5e5e415ec8b057c6c393972cae6f105d5f94364efbde6d21012c0286318dfee&token=1387203581&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener"><strong>大数据技术与架构</strong></a></p>
<p>原文链接   <a href="https://mp.weixin.qq.com/s/BHRGaReHypkE2H4qMRUkgA" target="_blank" rel="noopener">HiveSQL常用优化方法全面总结</a></p>
</blockquote>
<p>Hive作为大数据领域常用的数据仓库组件，在平时设计和查询时要特别注意效率。影响Hive效率的几乎从不是数据量过大，而是数据倾斜、数据冗余、job或I/O过多、MapReduce分配不合理等等。对Hive的调优既包含对HiveQL语句本身的优化，也包含Hive配置项和MR方面的调整。</p>
<h3 id="列裁剪和分区裁剪"><a href="#列裁剪和分区裁剪" class="headerlink" title="列裁剪和分区裁剪"></a><strong>列裁剪和分区裁剪</strong></h3><p>最基本的操作。所谓列裁剪就是在查询时只读取需要的列，分区裁剪就是只读取需要的分区。以我们的日历记录表为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select uid,event_type,record_data</span><br><span class="line">from calendar_record_log</span><br><span class="line">where pt_date &gt;= 20190201 and pt_date &lt;= 20190224</span><br><span class="line">and status = 0;</span><br></pre></td></tr></table></figure>

<p>当列很多或者数据量很大时，如果select *或者不指定分区，全列扫描和全表扫描效率都很低。<br>Hive中与列裁剪优化相关的配置项是<code>hive.optimize.cp</code>，与分区裁剪优化相关的则是<code>hive.optimize.pruner</code>，默认都是true。在HiveQL解析阶段对应的则是ColumnPruner逻辑优化器。</p>
<h3 id="谓词下推"><a href="#谓词下推" class="headerlink" title="谓词下推"></a><strong>谓词下推</strong></h3><p>在关系型数据库如MySQL中，也有谓词下推（Predicate Pushdown，PPD）的概念。它就是将SQL语句中的where谓词逻辑都尽可能提前执行，减少下游处理的数据量。<br>例如以下HiveQL语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select a.uid,a.event_type,b.topic_id,b.title</span><br><span class="line">from calendar_record_log a</span><br><span class="line">left outer join (</span><br><span class="line">  select uid,topic_id,title from forum_topic</span><br><span class="line">  where pt_date = 20190224 and length(content) &gt;= 100</span><br><span class="line">) b on a.uid = b.uid</span><br><span class="line">where a.pt_date = 20190224 and status = 0;</span><br></pre></td></tr></table></figure>

<p>对forum_topic做过滤的where语句写在子查询内部，而不是外部。Hive中有谓词下推优化的配置项<code>hive.optimize.ppd</code>，默认值true，与它对应的逻辑优化器是PredicatePushDown。该优化器就是将OperatorTree中的FilterOperator向上提，见下图。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfv47skxb5j30bo07yq45.jpg" alt="image-20200617111558247"></p>
<p>图来自<a href="https://tech.meituan.com/2014/02/12/hive-sql-to-mapreduce.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/02/12/hive-sql-to-mapreduce.html</a></p>
<p>上面的链接中是一篇讲解HiveQL解析与执行过程的好文章，前文提到的优化器、OperatorTree等概念在其中也有详细的解释，非常推荐。</p>
<h3 id="sort-by代替order-by"><a href="#sort-by代替order-by" class="headerlink" title="sort by代替order by"></a><strong>sort by代替order by</strong></h3><p>HiveQL中的order by与其他SQL方言中的功能一样，就是将结果按某字段全局排序，这会导致所有map端数据都进入一个reducer中，在数据量大时可能会长时间计算不完。<br>如果使用sort by，那么还是会视情况启动多个reducer进行排序，并且保证每个reducer内局部有序。为了控制map端数据分配到reducer的key，往往还要配合distribute by一同使用。如果不加distribute by的话，map端数据就会随机分配到reducer。<br>举个例子，假如要以UID为key，以上传时间倒序、记录类型倒序输出记录数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select uid,upload_time,event_type,record_data</span><br><span class="line">from calendar_record_log</span><br><span class="line">where pt_date &gt;= 20190201 and pt_date &lt;= 20190224</span><br><span class="line">distribute by uid</span><br><span class="line">sort by upload_time desc,event_type desc;</span><br></pre></td></tr></table></figure>

<h3 id="group-by代替distinct"><a href="#group-by代替distinct" class="headerlink" title="group by代替distinct"></a><strong>group by代替distinct</strong></h3><p>当要统计某一列的去重数时，如果数据量很大，count(distinct)就会非常慢，原因与order by类似，count(distinct)逻辑只会有很少的reducer来处理。这时可以用group by来改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(1) from (</span><br><span class="line">  select uid from calendar_record_log</span><br><span class="line">  where pt_date &gt;= 20190101</span><br><span class="line">  group by uid</span><br><span class="line">) t;</span><br></pre></td></tr></table></figure>

<p>但是这样写会启动两个MR job（单纯distinct只会启动一个），所以要确保数据量大到启动job的overhead远小于计算耗时，才考虑这种方法。当数据集很小或者key的倾斜比较明显时，group by还可能会比distinct慢。<br>那么如何用group by方式同时统计多个列？下面是解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select t.a,sum(t.b),count(t.c),count(t.d) from (</span><br><span class="line">  select a,b,null c,null d from some_table</span><br><span class="line">  union all</span><br><span class="line">  select a,0 b,c,null d from some_table group by a,c</span><br><span class="line">  union all</span><br><span class="line">  select a,0 b,null c,d from some_table group by a,d</span><br><span class="line">) t;</span><br></pre></td></tr></table></figure>

<h3 id="group-by配置调整"><a href="#group-by配置调整" class="headerlink" title="group by配置调整"></a><strong>group by配置调整</strong></h3><h4 id="map端预聚合"><a href="#map端预聚合" class="headerlink" title="map端预聚合"></a><strong>map端预聚合</strong></h4><p>group by时，如果先起一个combiner在map端做部分预聚合，可以有效减少shuffle数据量。预聚合的配置项是<code>hive.map.aggr</code>，默认值true，对应的优化器为GroupByOptimizer，简单方便。<br>通过<code>hive.groupby.mapaggr.checkinterval</code>参数也可以设置map端预聚合的行数阈值，超过该值就会分拆job，默认值100000。</p>
<h4 id="倾斜均衡配置项"><a href="#倾斜均衡配置项" class="headerlink" title="倾斜均衡配置项"></a><strong>倾斜均衡配置项</strong></h4><p>group by时如果某些key对应的数据量过大，就会发生数据倾斜。Hive自带了一个均衡数据倾斜的配置项<code>hive.groupby.skewindata</code>，默认值false。<br>其实现方法是在group by时启动两个MR job。第一个job会将map端数据随机输入reducer，每个reducer做部分聚合，相同的key就会分布在不同的reducer中。第二个job再将前面预处理过的数据按key聚合并输出结果，这样就起到了均衡的效果。<br>但是，配置项毕竟是死的，单纯靠它有时不能根本上解决问题，因此还是建议自行了解数据倾斜的细节，并优化查询语句。</p>
<h3 id="join基础优化"><a href="#join基础优化" class="headerlink" title="join基础优化"></a><strong>join基础优化</strong></h3><p>join优化是一个复杂的话题，下面先说5点最基本的注意事项。</p>
<h4 id="build-table（小表）前置"><a href="#build-table（小表）前置" class="headerlink" title="build table（小表）前置"></a><strong>build table（小表）前置</strong></h4><p>在最常见的hash join方法中，一般总有一张相对小的表和一张相对大的表，小表叫build table，大表叫probe table。如下图所示。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfv4767rjej30kt0b9aco.jpg" alt="image-20200617111519775"></p>
<p>Hive在解析带join的SQL语句时，会默认将最后一个表作为probe table，将前面的表作为build table并试图将它们读进内存。如果表顺序写反，probe table在前面，引发OOM的风险就高了。<br>在维度建模数据仓库中，事实表就是probe table，维度表就是build table。假设现在要将日历记录事实表和记录项编码维度表来join：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select a.event_type,a.event_code,a.event_desc,b.upload_time</span><br><span class="line">from calendar_event_code a</span><br><span class="line">inner join (</span><br><span class="line">  select event_type,upload_time from calendar_record_log</span><br><span class="line">  where pt_date = 20190225</span><br><span class="line">) b on a.event_type = b.event_type;</span><br></pre></td></tr></table></figure>

<h4 id="多表join时key相同"><a href="#多表join时key相同" class="headerlink" title="多表join时key相同"></a>多表join时key相同</h4><p>这种情况会将多个join合并为一个MR job来处理，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select a.event_type,a.event_code,a.event_desc,b.upload_time</span><br><span class="line">from calendar_event_code a</span><br><span class="line">inner join (</span><br><span class="line">  select event_type,upload_time from calendar_record_log</span><br><span class="line">  where pt_date = 20190225</span><br><span class="line">) b on a.event_type = b.event_type</span><br><span class="line">inner join (</span><br><span class="line">  select event_type,upload_time from calendar_record_log_2</span><br><span class="line">  where pt_date = 20190225</span><br><span class="line">) c on a.event_type = c.event_type;</span><br></pre></td></tr></table></figure>

<p>如果上面两个join的条件不相同，比如改成<code>a.event_code = c.event_code</code>，就会拆成两个MR job计算。<br>负责这个的是相关性优化器CorrelationOptimizer，它的功能除此之外还非常多，逻辑复杂，参考Hive官方的文档可以获得更多细节：<a href="https://cwiki.apache.org/confluence/display/Hive/Correlation+Optimizer。" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/Correlation+Optimizer。</a></p>
<h4 id="利用map-join特性"><a href="#利用map-join特性" class="headerlink" title="利用map join特性"></a>利用map join特性</h4><p>map join特别适合大小表join的情况。Hive会将build table和probe table在map端直接完成join过程，消灭了reduce，效率很高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select /*+mapjoin(a)*/ a.event_type,b.upload_time</span><br><span class="line">from calendar_event_code a</span><br><span class="line">inner join (</span><br><span class="line">  select event_type,upload_time from calendar_record_log</span><br><span class="line">  where pt_date = 20190225</span><br><span class="line">) b on a.event_type &lt; b.event_type;</span><br></pre></td></tr></table></figure>

<p>上面的语句中加了一条map join hint，以显式启用map join特性。早在Hive 0.8版本之后，就不需要写这条hint了。map join还支持不等值连接，应用更加灵活。<br>map join的配置项是<code>hive.auto.convert.join</code>，默认值true，对应逻辑优化器是MapJoinProcessor。<br>还有一些参数用来控制map join的行为，比如<code>hive.mapjoin.smalltable.filesize</code>，当build table大小小于该值就会启用map join，默认值25000000（25MB）。还有<code>hive.mapjoin.cache.numrows</code>，表示缓存build table的多少行数据到内存，默认值25000。</p>
<h4 id="分桶表map-join"><a href="#分桶表map-join" class="headerlink" title="分桶表map join"></a><strong>分桶表map join</strong></h4><p>map join对分桶表还有特别的优化。由于分桶表是基于一列进行hash存储的，因此非常适合抽样（按桶或按块抽样）。<br>它对应的配置项是<code>hive.optimize.bucketmapjoin</code>，优化器是BucketMapJoinOptimizer。但我们的业务中用分桶表较少，所以就不班门弄斧了，只是提一句。</p>
<h4 id="倾斜均衡配置项-1"><a href="#倾斜均衡配置项-1" class="headerlink" title="倾斜均衡配置项"></a><strong>倾斜均衡配置项</strong></h4><p>这个配置与上面group by的倾斜均衡配置项异曲同工，通过<code>hive.optimize.skewjoin</code>来配置，默认false。<br>如果开启了，在join过程中Hive会将计数超过阈值<code>hive.skewjoin.key</code>（默认100000）的倾斜key对应的行临时写进文件中，然后再启动另一个job做map join生成结果。通过<code>hive.skewjoin.mapjoin.map.tasks</code>参数还可以控制第二个job的mapper数量，默认10000。<br>再重复一遍，通过自带的配置项经常不能解决数据倾斜问题。join是数据倾斜的重灾区，后面还要介绍在SQL层面处理倾斜的各种方法。</p>
<h3 id="优化SQL处理join数据倾斜"><a href="#优化SQL处理join数据倾斜" class="headerlink" title="优化SQL处理join数据倾斜"></a><strong>优化SQL处理join数据倾斜</strong></h3><p>上面已经多次提到了数据倾斜，包括已经写过的sort by代替order by，以及group by代替distinct方法，本质上也是为了解决它。join操作更是数据倾斜的重灾区，需要多加注意。</p>
<h4 id="空值或无意义值"><a href="#空值或无意义值" class="headerlink" title="空值或无意义值"></a><strong>空值或无意义值</strong></h4><p>这种情况很常见，比如当事实表是日志类数据时，往往会有一些项没有记录到，我们视情况会将它置为null，或者空字符串、-1等。如果缺失的项很多，在做join时这些空值就会非常集中，拖累进度。<br>因此，若不需要空值数据，就提前写where语句过滤掉。需要保留的话，将空值key用随机方式打散，例如将用户ID为null的记录随机改为负值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select a.uid,a.event_type,b.nickname,b.age</span><br><span class="line">from (</span><br><span class="line">  select </span><br><span class="line">  (case when uid is null then cast(rand()*-10240 as int) else uid end) as uid,</span><br><span class="line">  event_type from calendar_record_log</span><br><span class="line">  where pt_date &gt;= 20190201</span><br><span class="line">) a left outer join (</span><br><span class="line">  select uid,nickname,age from user_info where status = 4</span><br><span class="line">) b on a.uid = b.uid;</span><br></pre></td></tr></table></figure>

<h4 id="单独处理倾斜key"><a href="#单独处理倾斜key" class="headerlink" title="单独处理倾斜key"></a><strong>单独处理倾斜key</strong></h4><p>这其实是上面处理空值方法的拓展，不过倾斜的key变成了有意义的。一般来讲倾斜的key都很少，我们可以将它们抽样出来，对应的行单独存入临时表中，然后打上一个较小的随机数前缀（比如0~9），最后再进行聚合。SQL语句与上面的相仿，不再赘述。</p>
<h4 id="不同数据类型"><a href="#不同数据类型" class="headerlink" title="不同数据类型"></a><strong>不同数据类型</strong></h4><p>这种情况不太常见，主要出现在相同业务含义的列发生过逻辑上的变化时。<br>举个例子，假如我们有一旧一新两张日历记录表，旧表的记录类型字段是(event_type int)，新表的是(event_type string)。为了兼容旧版记录，新表的event_type也会以字符串形式存储旧版的值，比如’17’。当这两张表join时，经常要耗费很长时间。其原因就是如果不转换类型，计算key的hash值时默认是以int型做的，这就导致所有“真正的”string型key都分配到一个reducer上。所以要注意类型转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select a.uid,a.event_type,b.record_data</span><br><span class="line">from calendar_record_log a</span><br><span class="line">left outer join (</span><br><span class="line">  select uid,event_type from calendar_record_log_2</span><br><span class="line">  where pt_date = 20190228</span><br><span class="line">) b on a.uid = b.uid and b.event_type = cast(a.event_type as string)</span><br><span class="line">where a.pt_date = 20190228;</span><br></pre></td></tr></table></figure>

<h4 id="build-table过大"><a href="#build-table过大" class="headerlink" title="build table过大"></a><strong>build table过大</strong></h4><p>有时，build table会大到无法直接使用map join的地步，比如全量用户维度表，而使用普通join又有数据分布不均的问题。这时就要充分利用probe table的限制条件，削减build table的数据量，再使用map join解决。代价就是需要进行两次join。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select /*+mapjoin(b)*/ a.uid,a.event_type,b.status,b.extra_info</span><br><span class="line">from calendar_record_log a</span><br><span class="line">left outer join (</span><br><span class="line">  select /*+mapjoin(s)*/ t.uid,t.status,t.extra_info</span><br><span class="line">  from (select distinct uid from calendar_record_log where pt_date = 20190228) s</span><br><span class="line">  inner join user_info t on s.uid = t.uid</span><br><span class="line">) b on a.uid = b.uid</span><br><span class="line">where a.pt_date = 20190228;</span><br></pre></td></tr></table></figure>

<h3 id="MapReduce优化"><a href="#MapReduce优化" class="headerlink" title="MapReduce优化"></a>MapReduce优化</h3><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<h4 id="调整mapper数"><a href="#调整mapper数" class="headerlink" title="调整mapper数"></a><strong>调整mapper数</strong></h4><p>mapper数量与输入文件的split数息息相关，在Hadoop源码<code>org.apache.hadoop.mapreduce.lib.input.FileInputFormat</code>类中可以看到split划分的具体逻辑。这里不贴代码，直接叙述mapper数是如何确定的。</p>
<ul>
<li>可以直接通过参数<code>mapred.map.tasks</code>（默认值2）来设定mapper数的期望值，但它不一定会生效，下面会提到。</li>
<li>设输入文件的总大小为<code>total_input_size</code>。HDFS中，一个块的大小由参数<code>dfs.block.size</code>指定，默认值64MB或128MB。在默认情况下，mapper数就是：<br><code>default_mapper_num = total_input_size / dfs.block.size</code>。</li>
<li>参数<code>mapred.min.split.size</code>（默认值1B）和<code>mapred.max.split.size</code>（默认值64MB）分别用来指定split的最小和最大大小。split大小和split数计算规则是：<br><code>split_size = MAX(mapred.min.split.size, MIN(mapred.max.split.size, dfs.block.size))</code>；
<code>split_num = total_input_size / split_size</code>。</li>
<li>得出mapper数：<br><code>mapper_num = MIN(split_num, MAX(default_num, mapred.map.tasks))</code>。</li>
</ul>
<p>可见，如果想减少mapper数，就适当调高<code>mapred.min.split.size</code>，split数就减少了。如果想增大mapper数，除了降低<code>mapred.min.split.size</code>之外，也可以调高<code>mapred.map.tasks</code>。
一般来讲，如果输入文件是少量大文件，就减少mapper数；如果输入文件是大量非小文件，就增大mapper数；至于大量小文件的情况，得参考下面“合并小文件”一节的方法处理。</p>
<h4 id="调整reducer数"><a href="#调整reducer数" class="headerlink" title="调整reducer数"></a><strong>调整reducer数</strong></h4><p>reducer数量的确定方法比mapper简单得多。使用参数<code>mapred.reduce.tasks</code>可以直接设定reducer数量，不像mapper一样是期望值。但如果不设这个参数的话，Hive就会自行推测，逻辑如下：</p>
<ul>
<li>参数<code>hive.exec.reducers.bytes.per.reducer</code>用来设定每个reducer能够处理的最大数据量，默认值1G（1.2版本之前）或256M（1.2版本之后）。</li>
<li>参数<code>hive.exec.reducers.max</code>用来设定每个job的最大reducer数量，默认值999（1.2版本之前）或1009（1.2版本之后）。</li>
<li>得出reducer数：<br><code>reducer_num = MIN(total_input_size / reducers.bytes.per.reducer, reducers.max)</code>。</li>
</ul>
<p>reducer数量与输出文件的数量相关。如果reducer数太多，会产生大量小文件，对HDFS造成压力。如果reducer数太少，每个reducer要处理很多数据，容易拖慢运行时间或者造成OOM。</p>
<h4 id="合并小文件"><a href="#合并小文件" class="headerlink" title="合并小文件"></a><strong>合并小文件</strong></h4><ul>
<li>输入阶段合并<br>需要更改Hive的输入文件格式，即参数<code>hive.input.format</code>，默认值是<code>org.apache.hadoop.hive.ql.io.HiveInputFormat</code>，我们改成<code>org.apache.hadoop.hive.ql.io.CombineHiveInputFormat</code>。
这样比起上面调整mapper数时，又会多出两个参数，分别是<code>mapred.min.split.size.per.node</code>和<code>mapred.min.split.size.per.rack</code>，含义是单节点和单机架上的最小split大小。如果发现有split大小小于这两个值（默认都是100MB），则会进行合并。具体逻辑可以参看Hive源码中的对应类。</li>
<li>输出阶段合并<br>直接将<code>hive.merge.mapfiles</code>和<code>hive.merge.mapredfiles</code>都设为true即可，前者表示将map-only任务的输出合并，后者表示将map-reduce任务的输出合并。<br>另外，<code>hive.merge.size.per.task</code>可以指定每个task输出后合并文件大小的期望值，<code>hive.merge.size.smallfiles.avgsize</code>可以指定所有输出文件大小的均值阈值，默认值都是1GB。如果平均大小不足的话，就会另外启动一个任务来进行合并。</li>
</ul>
<h4 id="启用压缩"><a href="#启用压缩" class="headerlink" title="启用压缩"></a><strong>启用压缩</strong></h4><p>压缩job的中间结果数据和输出数据，可以用少量CPU时间节省很多空间。压缩方式一般选择Snappy，效率最高。<br>要启用中间压缩，需要设定<code>hive.exec.compress.intermediate</code>为true，同时指定压缩方式<code>hive.intermediate.compression.codec</code>为<code>org.apache.hadoop.io.compress.SnappyCodec</code>。另外，参数<code>hive.intermediate.compression.type</code>可以选择对块（BLOCK）还是记录（RECORD）压缩，BLOCK的压缩率比较高。<br>输出压缩的配置基本相同，打开<code>hive.exec.compress.output</code>即可。</p>
<h4 id="JVM重用"><a href="#JVM重用" class="headerlink" title="JVM重用"></a><strong>JVM重用</strong></h4><p>在MR job中，默认是每执行一个task就启动一个JVM。如果task非常小而碎，那么JVM启动和关闭的耗时就会很长。可以通过调节参数<code>mapred.job.reuse.jvm.num.tasks</code>来重用。例如将这个参数设成5，那么就代表同一个MR job中顺序执行的5个task可以重复使用一个JVM，减少启动和关闭的开销。但它对不同MR job中的task无效。</p>
<h3 id="并行执行与本地模式"><a href="#并行执行与本地模式" class="headerlink" title="并行执行与本地模式"></a><strong>并行执行与本地模式</strong></h3><ul>
<li>并行执行<br>Hive中互相没有依赖关系的job间是可以并行执行的，最典型的就是多个子查询union all。在集群资源相对充足的情况下，可以开启并行执行，即将参数<code>hive.exec.parallel</code>设为true。另外<code>hive.exec.parallel.thread.number</code>可以设定并行执行的线程数，默认为8，一般都够用。</li>
<li>本地模式<br>Hive也可以不将任务提交到集群进行运算，而是直接在一台节点上处理。因为消除了提交到集群的overhead，所以比较适合数据量很小，且逻辑不复杂的任务。<br>设置<code>hive.exec.mode.local.auto</code>为true可以开启本地模式。但任务的输入数据总量必须小于<code>hive.exec.mode.local.auto.inputbytes.max</code>（默认值128MB），且mapper数必须小于<code>hive.exec.mode.local.auto.tasks.max</code>（默认值4），reducer数必须为0或1，才会真正用本地模式执行。</li>
</ul>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a><strong>严格模式</strong></h3><p>所谓严格模式，就是强制不允许用户执行3种有风险的HiveQL语句，一旦执行会直接失败。这3种语句是：</p>
<ul>
<li>查询分区表时不限定分区列的语句；</li>
<li>两表join产生了笛卡尔积的语句；</li>
<li>用order by来排序但没有指定limit的语句。</li>
</ul>
<p>要开启严格模式，需要将参数<code>hive.mapred.mode</code>设为strict。</p>
<h3 id="采用合适的存储格式"><a href="#采用合适的存储格式" class="headerlink" title="采用合适的存储格式"></a><strong>采用合适的存储格式</strong></h3><p>在HiveQL的create table语句中，可以使用<code>stored as ...</code>指定表的存储格式。Hive表支持的存储格式有TextFile、SequenceFile、RCFile、Avro、ORC、Parquet等。<br>存储格式一般需要根据业务进行选择，在我们的实操中，绝大多数表都采用TextFile与Parquet两种存储格式之一。<br>TextFile是最简单的存储格式，它是纯文本记录，也是Hive的默认格式。虽然它的磁盘开销比较大，查询效率也低，但它更多地是作为跳板来使用。RCFile、ORC、Parquet等格式的表都不能由文件直接导入数据，必须由TextFile来做中转。<br>Parquet和ORC都是Apache旗下的开源列式存储格式。列式存储比起传统的行式存储更适合批量OLAP查询，并且也支持更好的压缩和编码。我们选择Parquet的原因主要是它支持Impala查询引擎，并且我们对update、delete和事务性操作需求很低。<br>这里就不展开讲它们的细节，可以参考各自的官网：<br><a href="https://parquet.apache.org/" target="_blank" rel="noopener">https://parquet.apache.org/</a><br><a href="https://orc.apache.org/" target="_blank" rel="noopener">https://orc.apache.org/</a></p>
<p><strong>——END——</strong></p>

    </div>

    
    
    
    
      <div>
        <div id="reward-container">
  <div></div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.png" alt="Eli 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.png" alt="Eli 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      </div>
      <div>
        

<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Eli</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://chenqikai.github.io/2020/06/17/HiveSQL常用优化方法总结/" title="HiveSQL常用优化方法总结">http://chenqikai.github.io/2020/06/17/HiveSQL常用优化方法总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/HIVE/" rel="tag"># HIVE</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2020/03/01/Spark 数据倾斜及其解决方案/" rel="next" title="Spark 数据倾斜及其解决方案">
                <i class="fa fa-chevron-left"></i> Spark 数据倾斜及其解决方案
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.gif"
      alt="Eli">
  <p class="site-author-name" itemprop="name">Eli</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:1610252715@vip.henu.edu.cn" title="E-Mail &rarr; mailto:1610252715@vip.henu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="http://39.106.192.112/" title="Resume &rarr; http://39.106.192.112/" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>Resume</a>
      </span>
    
  </div>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#列裁剪和分区裁剪"><span class="nav-number">1.</span> <span class="nav-text">列裁剪和分区裁剪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谓词下推"><span class="nav-number">2.</span> <span class="nav-text">谓词下推</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-by代替order-by"><span class="nav-number">3.</span> <span class="nav-text">sort by代替order by</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#group-by代替distinct"><span class="nav-number">4.</span> <span class="nav-text">group by代替distinct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#group-by配置调整"><span class="nav-number">5.</span> <span class="nav-text">group by配置调整</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#map端预聚合"><span class="nav-number">5.1.</span> <span class="nav-text">map端预聚合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#倾斜均衡配置项"><span class="nav-number">5.2.</span> <span class="nav-text">倾斜均衡配置项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join基础优化"><span class="nav-number">6.</span> <span class="nav-text">join基础优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#build-table（小表）前置"><span class="nav-number">6.1.</span> <span class="nav-text">build table（小表）前置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多表join时key相同"><span class="nav-number">6.2.</span> <span class="nav-text">多表join时key相同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#利用map-join特性"><span class="nav-number">6.3.</span> <span class="nav-text">利用map join特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分桶表map-join"><span class="nav-number">6.4.</span> <span class="nav-text">分桶表map join</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#倾斜均衡配置项-1"><span class="nav-number">6.5.</span> <span class="nav-text">倾斜均衡配置项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化SQL处理join数据倾斜"><span class="nav-number">7.</span> <span class="nav-text">优化SQL处理join数据倾斜</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#空值或无意义值"><span class="nav-number">7.1.</span> <span class="nav-text">空值或无意义值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单独处理倾斜key"><span class="nav-number">7.2.</span> <span class="nav-text">单独处理倾斜key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不同数据类型"><span class="nav-number">7.3.</span> <span class="nav-text">不同数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#build-table过大"><span class="nav-number">7.4.</span> <span class="nav-text">build table过大</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MapReduce优化"><span class="nav-number">8.</span> <span class="nav-text">MapReduce优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调整mapper数"><span class="nav-number">8.1.</span> <span class="nav-text">调整mapper数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调整reducer数"><span class="nav-number">8.2.</span> <span class="nav-text">调整reducer数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合并小文件"><span class="nav-number">8.3.</span> <span class="nav-text">合并小文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启用压缩"><span class="nav-number">8.4.</span> <span class="nav-text">启用压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM重用"><span class="nav-number">8.5.</span> <span class="nav-text">JVM重用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并行执行与本地模式"><span class="nav-number">9.</span> <span class="nav-text">并行执行与本地模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#严格模式"><span class="nav-number">10.</span> <span class="nav-text">严格模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#采用合适的存储格式"><span class="nav-number">11.</span> <span class="nav-text">采用合适的存储格式</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eli</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">288k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:22</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a></div>

        








        
      </div>
    </footer>

    

  </div>

  
    
    
  
  <script color='12,154,255' opacity='1' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>

  
  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>



  <script src="/js/next-boot.js?v=7.3.0"></script>

  

  

  


  





















  <script src="/js/local-search.js?v=7.3.0"></script>














<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
