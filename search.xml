<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDFS读写数据流程]]></title>
    <url>%2F2019%2F11%2F06%2FHDFS%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[HDFS的数据流HDFS写数据流程 1）客户端通过Distributed FileSystem模块向NameNode请求上传文件，NameNode检查目标文件是否已存在，父目录是否存在。 2）NameNode返回是否可以上传。 3）客户端请求第一个 Block上传到哪几个DataNode服务器上。 4）NameNode返回3个DataNode节点，分别为dn1、dn2、dn3。 5）客户端通过FSDataOutputStream模块请求dn1上传数据，dn1收到请求会继续调用dn2，然后dn2调用dn3，将这个通信管道建立完成。 6）dn1、dn2、dn3逐级应答客户端。 7）客户端开始往dn1上传第一个Block（先从磁盘读取数据放到一个本地内存缓存），以Packet为单位，dn1收到一个Packet就会传给dn2，dn2传给dn3；dn1每传一个packet会放入一个应答队列等待应答。 8）当一个Block传输完成之后，客户端再次请求NameNode上传第二个Block的服务器。（重复执行3-7步）。 HDFS读数据流程 1）客户端通过Distributed FileSystem向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址。 2）挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据。 3）DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。 4）客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。 副本节点选择的副本放置策略的基本思想是：1.第一副本：放置在上传文件的DataNode上;如果是集群外提交，则随机挑选一台磁盘不太慢，CPU不太忙的节点上; 2.第二副本：放置在于第一个副本不同的机架节点上; 3.第三副本：与第二个副本相同机架的不同节点上; 4.如果还有更多的副本，则随机放在节点中。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>HDFS</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集群同步脚本xsync]]></title>
    <url>%2F2019%2F11%2F05%2F%E9%9B%86%E7%BE%A4%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%ACxsync%2F</url>
    <content type="text"><![CDATA[该脚本用于在所有主机上同步文件。在 /usr/local/bin目录下,创建文件xsync，向里面添加如下代码： 12345678910111213141516171819202122232425#!/bin/bash#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if((pcount==0)); thenecho no args;exit;fi#2 获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3 获取上级目录到绝对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4 获取当前用户名称user=`whoami`#5 循环for((host=102; host&lt;104; host++)); do echo ------------------- hadoop$host -------------- rsync -rvl $pdir/$fname $user@hadoop$host:$pdirdone 使用chmod a+x xsync给文件添加执行权限]]></content>
      <categories>
        <category>集群管理</category>
      </categories>
      <tags>
        <tag>集群管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集群批量命令脚本xcall]]></title>
    <url>%2F2019%2F11%2F05%2F%E9%9B%86%E7%BE%A4%E6%89%B9%E9%87%8F%E5%91%BD%E4%BB%A4%E8%84%9A%E6%9C%ACxcall%2F</url>
    <content type="text"><![CDATA[该脚本用于在所有主机上同时执行相同的命令。在 /usr/local/bin目录下,创建文件xcall，向里面添加： 1234567891011#!/bin/shpcount=$#if((pcount==0));then echo no args...; exit;fifor((host=101; host&lt;=103; host++)); do echo ==================hadoop$host================== ssh hadoop$host $@done#Note:这里的hadoop是对应自己主机名，需要做相应修改。另外，for循环中的host的边界值由自己的主机编号决定。 最后chmod a+x xcall给文件添加执行权限即可。 但是在使用xcall执行jps时，经常出现 bash: jsp: 未找到命令 需要在 /usr/local/bin目录下创建jps软连接 1`cd` `/usr/local/bin` `ln` `-s ``/opt/jdk/bin/jps` `jps`]]></content>
      <categories>
        <category>集群管理</category>
      </categories>
      <tags>
        <tag>集群管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop集群时间同步]]></title>
    <url>%2F2019%2F11%2F04%2FHadoop%E9%9B%86%E7%BE%A4%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[Hadoop集群时间同步测试环境 IP 节点角色 主机名 10.10.101.100 master hadoop100 10.10.101.101 node hadoop101 10.10.101.102 node hadoop102 设置master服务器时间（1）检查ntp是否安装,若没有安装则使用yum install -y ntp进行安装1234567[root@hadoop101 桌面]# rpm -qa|grep ntpntp-4.2.6p5-10.el6.centos.x86_64fontpackages-filesystem-1.41-1.1.el6.noarchntpdate-4.2.6p5-10.el6.centos.x86_64 （2）修改ntp配置文件1[root@hadoop101 桌面]# vim /etc/ntp.conf 修改内容如下 a）修改1（授权192.168.1.0网段上的所有机器可以从这台机器上查询和同步时间） 123#restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap为restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap b）修改2（集群在局域网中，不使用其他的网络时间） 123456789server 0.centos.pool.ntp.org iburstserver 1.centos.pool.ntp.org iburstserver 2.centos.pool.ntp.org iburstserver 3.centos.pool.ntp.org iburst为#server 0.centos.pool.ntp.org iburst#server 1.centos.pool.ntp.org iburst#server 2.centos.pool.ntp.org iburst#server 3.centos.pool.ntp.org iburst c）添加3（当该节点丢失网络连接，依然可以作为时间服务器为集群中的其他节点提供时间同步） 12server 127.127.1.0fudge 127.127.1.0 stratum 10 （3）修改/etc/sysconfig/ntpd 文件1[root@hadoop101 桌面]# vim /etc/sysconfig/ntpd 增加内容如下（让硬件时间与系统时间一起同步） 1SYNC_HWCLOCK=yes （4）重新启动ntpd1234567[root@hadoop101 桌面]# service ntpd statusntpd 已停[root@hadoop101 桌面]# service ntpd start正在启动 ntpd： [确定] （5）设置开机自启动：1[root@hadoop101 桌面]# chkconfig ntpd on node配置（必须root用户）（1）在node配置10分钟与时间服务器同步一次12345[root@hadoop102 hadoop-2.7.2]# crontab -e#添加如下任务*/10 * * * * /usr/sbin/ntpdate hadoop101 （2）修改任意node时间1[root@hadoop102 root]# date -s &quot;2017-9-11 11:11:11&quot; （3）十分钟后查看机器是否与时间服务器同步1[root@hadoop102 root]# date]]></content>
      <categories>
        <category>集群管理</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDFS入门]]></title>
    <url>%2F2019%2F11%2F02%2FHDFS%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[HDFS概述HDFS的产生背景随着数据量越来越大，在一个操作系统存不下所有的数据，那么就分配到更多的操作系统管理的磁盘中，但是不方便管理和维护，迫切需要一种系统来管理多台机器上的文件，这就是分布式文件管理系统。HDFS只是分布式文件管理系统中的一种。 HDFS概念HDFS（Hadoop Distributed File System），它是一个文件系统，用于存储文件，通过目录树来定位文件；其次，它是分布式的，由很多服务器联合起来实现其功能，集群中的服务器有各自的角色。集群不一定是分布式的，但是分布式一定是集群。HDFS的设计适合一次写入，多次读出的场景，且不支持文件的修改。适合用来做数据分析，并不适合用来做网盘应用。 HDFS优缺点优点 1）高容错性（1）数据自动保存多个副本。它通过增加副本的形式，提高容错性；（2）某一个副本丢失以后，它可以自动恢复。 2）适合大数据处理（1）数据规模：能够处理数据规模达到GB、TB、甚至PB级别的数据；（2）文件规模：能够处理百万规模以上的文件数量，数量相当之大。 3）可构建在廉价机器上，通过多副本机制，提高可靠性。缺点 1）不适合低延时数据访问，比如毫秒级的存储数据，是做不到的。 2）无法高效的对大量小文件进行存储。（1）存储大量小文件的话，它会占用NameNode大量的内存来存储文件、目录和块信息。这样是不可取的，因为NameNode的内存总是有限的；（2）小文件存储的寻址时间会超过读取时间，它违反了HDFS的设计目标。注：寻址时间，目前技术水平在10ms左右 2、传输寻址时间/传输时间=1%，传输时间1000ms=1s，磁盘传输速度100M/S,计算机是2的n次方，所以hadoop2.x默认块的大小为128m 3）不支持并发写入、文件随机修改。（1）一个文件只能有一个写，不允许多个线程同时写；（2）仅支持数据append（追加），不支持文件的随机修改。 HDFS组成架构HDFS组成架构如下图所示 架构主要由四个部分组成，分别为HDFS Client、NameNode、DataNode和Secondary NameNode。下面我们分别介绍这四个组成部分。 1）Client：就是客户端。 ​ （1）文件切分。文件上传HDFS的时候，Client将文件切分成一个一个的Block，然后进行存储； ​ （2）与NameNode交互，获取文件的位置信息； ​ （3）与DataNode交互，读取或者写入数据； ​ （4）Client提供一些命令来管理HDFS，比如启动或者关闭HDFS； ​ （5）Client可以通过一些命令来访问HDFS； 2）NameNode：就是Master，它是一个主管、管理者。 ​ （1）管理HDFS的名称空间；namespace ​ （2）管理数据块（Block）映射信息； ​ （3）配置副本策略（默认）；3 ​ （4）处理客户端读写请求。 3） DataNode：就是Slave。NameNode下达命令，DataNode执行实际的操作。 ​ （1）存储实际的数据块； ​ （2）执行数据块的读/写操作。 4） SecondaryNameNode：并非NameNode的热备。当NameNode挂掉的时候，它并不能马上替换NameNode并提供服务。 ​ （1）辅助NameNode，分担其工作量； ​ （2）定期合并Fsimage和Edits，并推送给NameNode； ​ （3）在紧急情况下，可辅助恢复NameNode。 HDFS文件块大小HDFS中的文件在物理上是分块存储（block），块的大小可以通过配置参数( dfs.blocksize)来规定，默认大小在hadoop2.x版本中是128M，老版本中是64M。 HDFS的Shell客户端操作cat使用方法：hadoop fs -cat URI [URI …] 将路径指定文件的内容输出到stdout。 示例： hadoop fs -cat hdfs://host1:port1/file1 hdfs://host2:port2/file2 hadoop fs -cat file:///file3 /user/hadoop/file4 返回值：成功返回0，失败返回-1。 chgrp使用方法：hadoop fs -chgrp [-R] GROUP URI [URI …] Change group association of files. With -R, make the change recursively through the directory structure. The user must be the owner of files, or else a super-user. Additional information is in the Permissions User Guide. –&gt; 改变文件所属的组。使用-R将使改变在目录结构下递归进行。命令的使用者必须是文件的所有者或者超级用户。更多的信息请参见HDFS权限用户指南。 chmod使用方法：hadoop fs -chmod [-R] &lt;MODE[,MODE]… | OCTALMODE&gt; URI [URI …] 改变文件的权限。使用-R将使改变在目录结构下递归进行。命令的使用者必须是文件的所有者或者超级用户。更多的信息请参见HDFS权限用户指南。 chown使用方法：hadoop fs -chown [-R] [OWNER][:[GROUP]] URI [URI ] 改变文件的拥有者。使用-R将使改变在目录结构下递归进行。命令的使用者必须是超级用户。更多的信息请参见HDFS权限用户指南。 copyFromLocal使用方法：hadoop fs -copyFromLocal URI 除了限定源路径是一个本地文件外，和put命令相似。 copyToLocal使用方法：hadoop fs -copyToLocal [-ignorecrc] [-crc] URI 除了限定目标路径是一个本地文件外，和get命令类似。 cp使用方法：hadoop fs -cp URI [URI …] 将文件从源路径复制到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。示例： hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2 hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2 /user/hadoop/dir 返回值： 成功返回0，失败返回-1。 du使用方法：hadoop fs -du URI [URI …] 显示目录中所有文件的大小，或者当只指定一个文件时，显示此文件的大小。示例：hadoop fs -du /user/hadoop/dir1 /user/hadoop/file1 hdfs://host:port/user/hadoop/dir1返回值：成功返回0，失败返回-1。 dus使用方法：hadoop fs -dus 显示文件的大小。 expunge使用方法：hadoop fs -expunge 清空回收站。请参考HDFS设计文档以获取更多关于回收站特性的信息。 get使用方法：hadoop fs -get [-ignorecrc] [-crc] 复制文件到本地文件系统。可用-ignorecrc选项复制CRC校验失败的文件。使用-crc选项复制文件以及CRC信息。 示例： hadoop fs -get /user/hadoop/file localfile hadoop fs -get hdfs://host:port/user/hadoop/file localfile 返回值： 成功返回0，失败返回-1。 getmerge使用方法：hadoop fs -getmerge [addnl] 接受一个源目录和一个目标文件作为输入，并且将源目录中所有的文件连接成本地目标文件。addnl是可选的，用于指定在每个文件结尾添加一个换行符。 ls使用方法：hadoop fs -ls 如果是文件，则按照如下格式返回文件信息：文件名 &lt;副本数&gt; 文件大小 修改日期 修改时间 权限 用户ID 组ID如果是目录，则返回它直接子文件的一个列表，就像在Unix中一样。目录返回列表的信息如下：目录名 修改日期 修改时间 权限 用户ID 组ID示例：hadoop fs -ls /user/hadoop/file1 /user/hadoop/file2 hdfs://host:port/user/hadoop/dir1 /nonexistentfile返回值：成功返回0，失败返回-1。 lsr使用方法：hadoop fs -lsr ls命令的递归版本。类似于Unix中的ls -R。 mkdir使用方法：hadoop fs -mkdir 接受路径指定的uri作为参数，创建这些目录。其行为类似于Unix的mkdir -p，它会创建路径中的各级父目录。 示例： hadoop fs -mkdir /user/hadoop/dir1 /user/hadoop/dir2 hadoop fs -mkdir hdfs://host1:port1/user/hadoop/dir hdfs://host2:port2/user/hadoop/dir 返回值： 成功返回0，失败返回-1。 movefromLocal使用方法：dfs -moveFromLocal 输出一个”not implemented“信息。 mv使用方法：hadoop fs -mv URI [URI …] 将文件从源路径移动到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。不允许在不同的文件系统间移动文件。示例： hadoop fs -mv /user/hadoop/file1 /user/hadoop/file2 hadoop fs -mv hdfs://host:port/file1 hdfs://host:port/file2 hdfs://host:port/file3 hdfs://host:port/dir1 返回值： 成功返回0，失败返回-1。 put使用方法：hadoop fs -put … 从本地文件系统中复制单个或多个源路径到目标文件系统。也支持从标准输入中读取输入写入目标文件系统。 hadoop fs -put localfile /user/hadoop/hadoopfile hadoop fs -put localfile1 localfile2 /user/hadoop/hadoopdir hadoop fs -put localfile hdfs://host:port/hadoop/hadoopfile hadoop fs -put - hdfs://host:port/hadoop/hadoopfile从标准输入中读取输入。 返回值： 成功返回0，失败返回-1。 rm使用方法：hadoop fs -rm URI [URI …] 删除指定的文件。只删除非空目录和文件。请参考rmr命令了解递归删除。示例： hadoop fs -rm hdfs://host:port/file /user/hadoop/emptydir 返回值： 成功返回0，失败返回-1。 rmr使用方法：hadoop fs -rmr URI [URI …] delete的递归版本。示例： hadoop fs -rmr /user/hadoop/dir hadoop fs -rmr hdfs://host:port/user/hadoop/dir 返回值： 成功返回0，失败返回-1。 setrep使用方法：hadoop fs -setrep [-R] 改变一个文件的副本系数。-R选项用于递归改变目录下所有文件的副本系数。 示例： hadoop fs -setrep -w 3 -R /user/hadoop/dir1 返回值： 成功返回0，失败返回-1。 stat使用方法：hadoop fs -stat URI [URI …] 返回指定路径的统计信息。 示例： hadoop fs -stat path 返回值：成功返回0，失败返回-1。 tail使用方法：hadoop fs -tail [-f] URI 将文件尾部1K字节的内容输出到stdout。支持-f选项，行为和Unix中一致。 示例： hadoop fs -tail pathname 返回值：成功返回0，失败返回-1。 test使用方法：hadoop fs -test -[ezd] URI 选项：-e 检查文件是否存在。如果存在则返回0。-z 检查文件是否是0字节。如果是则返回0。-d 如果路径是个目录，则返回1，否则返回0。 示例： hadoop fs -test -e filename text使用方法：hadoop fs -text 将源文件输出为文本格式。允许的格式是zip和TextRecordInputStream。 touchz使用方法：hadoop fs -touchz URI [URI …] 创建一个0字节的空文件。 示例： hadoop -touchz pathname 返回值：成功返回0，失败返回-1。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>HDFS</tag>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[==和equals()方法]]></title>
    <url>%2F2019%2F08%2F17%2F%3D%3D%E5%92%8Cequals%2F</url>
    <content type="text"><![CDATA[“==”java中==为关系运算符,表示左边的数据是否和右边的数据相等，相等返回true否则返回false。基本数据类型之间的比较直接使用==，java是面向对象的语言，除了基本数据类型外的全部都为引用数据类型，也就是对象类型。引用数据类型在内存中的存储分为两部分，栈空间存储的为堆空间内存地址，堆空间存储实际的数据。直接使用==比较的是内存地址，但所得到的结果可能并不是我们想要的。比如String的比较 12345678910代码段1：String str1 = &quot;aa&quot;;String str2 = &quot;aa&quot;;System.out.println(str1 == str2); //trueSystem.out.println(str1.equals(str2)); //true代码段2：String str3 = new String(&quot;cc&quot;);String str4 = new String(&quot;cc&quot;);System.out.println(str3 == str4); //falseSystem.out.println(str3.equals(str4)); //true 看以上代码发现str1==str2为true而str3==str4为false，原因是因为java在编译期会将相同的字符串当做一个对象放入常量池，所以str1和str2为同一个对象，==也为true。使用new String()来创建对象会强制创建两个不同的对象，所以str3==str4为false。所以引用数据类型之间的比较一定不能使用==，而应使用equals()方法。 equals()方法equals()方法为Object类的方法，源码如下； Object类中的equals()方法和==比较是相同的，返回的是==比较的结果。为了能使equals()方法比较对象的内容我们必须重写equals()方法。 String类中重写了equals()方法。源码如下： String类的equals()方法首先比较的是不是同一个对象，是直接返回true，不是则判断是否是String类的对象，不是返回false，是接着比较字符串中的每一个char是否都相同，相同则返回true，否则返回false。 所以String使用equals()方法比较的是字符串的内容。 我们自己写的类中可以使用IDE工具直接生成equals()方法，使其比较对象中的内容。]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一千行MySQL学习笔记]]></title>
    <url>%2F2019%2F08%2F12%2F%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[原文地址：https://shockerli.net/post/1000-line-mysql-note/ 作者：格物 基本操作123456789/* Windows服务 */-- 启动MySQL net start mysql-- 创建Windows服务 sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)/* 连接与断开服务器 */mysql -h 地址 -P 端口 -u 用户名 -p 密码SHOW PROCESSLIST -- 显示哪些线程正在运行SHOW VARIABLES -- 显示系统变量信息 数据库操作12345678910111213141516171819/* 数据库操作 */ -------------------- 查看当前数据库 SELECT DATABASE();-- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version();-- 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name-- 查看已有库 SHOW DATABASES[ LIKE &apos;PATTERN&apos;]-- 查看当前库信息 SHOW CREATE DATABASE 数据库名-- 修改库的选项信息 ALTER DATABASE 库名 选项信息-- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容 表的操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576-- 创建表 CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &apos;string&apos;]-- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = &apos;目录&apos; -- 索引文件目录 INDEX DIRECTORY = &apos;目录&apos; -- 表注释 COMMENT = &apos;string&apos; -- 分区选项 PARTITION BY ... (详细见手册)-- 查看所有表 SHOW TABLES[ LIKE &apos;pattern&apos;] SHOW TABLES FROM 库名-- 查看表机构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &apos;PATTERN&apos;] SHOW TABLE STATUS [FROM db_name] [LIKE &apos;pattern&apos;]-- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键-- 删除表 DROP TABLE[ IF EXISTS] 表名 ...-- 清空表数据 TRUNCATE [TABLE] 表名-- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名-- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名-- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ...-- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...-- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]-- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 数据操作1234567891011121314151617/* 数据操作 */ -------------------- 增 INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]-- 查 SELECT 字段列表 FROM 表名[ 其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段-- 删 DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部-- 改 UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件] 字符集编码123456789101112131415161718/* 字符集编码 */ -------------------- MySQL、数据库、表、字段均可设置编码-- 数据编码与客户端编码不需一致SHOW VARIABLES LIKE &apos;character_set_%&apos; -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码SET 变量名 = 变量值 SET character_set_client = gbk; SET character_set_results = gbk; SET character_set_connection = gbk;SET NAMES GBK; -- 相当于完成以上三个设置-- 校对集 校对集用以排序 SHOW CHARACTER SET [LIKE &apos;pattern&apos;]/SHOW CHARSET [LIKE &apos;pattern&apos;] 查看所有字符集 SHOW COLLATION [LIKE &apos;pattern&apos;] 查看所有校对集 CHARSET 字符集编码 设置字符集编码 COLLATE 校对集编码 设置校对集编码 数据类型(列类型)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* 数据类型（列类型） */ ------------------1. 数值类型-- a. 整型 ---------- 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 - 默认存在符号位，unsigned 属性修改 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数&apos;123&apos;，补填后为&apos;00123&apos; - 在满足要求的情况下，越小越好。 - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。-- b. 浮点型 ---------- 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) M表示总位数，D表示小数位数。 M和D的大小会决定浮点数的范围。不同于整型的固定范围。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。-- c. 定点数 ---------- decimal -- 可变长度 decimal(M, D) M也表示总位数，D表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。2. 字符串类型-- a. char, varchar ---------- char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3-- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值-- c. binary, varbinary ---------- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob.3. 日期时间类型 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155datetime YYYY-MM-DD hh:mm:sstimestamp YY-MM-DD hh:mm:ss YYYYMMDDhhmmss YYMMDDhhmmss YYYYMMDDhhmmss YYMMDDhhmmssdate YYYY-MM-DD YY-MM-DD YYYYMMDD YYMMDD YYYYMMDD YYMMDDtime hh:mm:ss hhmmss hhmmssyear YYYY YY YYYY YY4. 枚举和集合-- 枚举(enum) ----------enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。-- 集合（set） ----------set(val1, val2, val3...) create table tab ( gender set(&apos;男&apos;, &apos;女&apos;, &apos;无&apos;) ); insert into tab values (&apos;男, 女&apos;); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。 列属性(列约束)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 列属性（列约束） */ ------------------1. PRIMARY 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));2. UNIQUE 唯一索引（唯一约束） 使得某字段的值也不能重复。3. NULL 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, &apos;val&apos;); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null4. DEFAULT 默认值属性 当前字段的默认值。 insert into tab values (default, &apos;val&apos;); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time5. AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;6. COMMENT 注释 例：create table tab ( id int ) comment &apos;注释内容&apos;;7. FOREIGN KEY 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。 建表规范1234567891011121314/* 建表规范 */ ------------------ -- Normal Format, NF - 每个表保存一个实体信息 - 每个具有一个ID字段作为主键 - ID主键 + 原子表 -- 1NF, 第一范式 字段不能再分，就满足第一范式。 -- 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 -- 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。 SELECT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* SELECT */ ------------------SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMITa. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb;b. FROM 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 SELECT * FROM tb1 AS tt, tb2 AS bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 SELECT * FROM tb1, tb2; -- 向优化符提示如何选择索引 USE INDEX、IGNORE INDEX、FORCE INDEX SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3; SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;c. WHERE 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较d. GROUP BY 子句, 分组子句 GROUP BY 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。e. HAVING 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。f. ORDER BY 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。g. LIMIT 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数h. DISTINCT, ALL 选项 distinct 去除重复记录 默认为 all, 全部记录 UNION12345678/* UNION */ ------------------ 将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。 ORDER BY 排序时，需加上 LIMIT 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。 子查询1234567891011121314151617181920212223242526272829/* 子查询 */ ------------------ - 子查询需用括号包裹。-- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;-- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。 连接查询(join)123456789101112131415161718192021222324/* 连接查询(join) */ ------------------ 将多个表的字段进行连接，可以指定连接条件。-- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2;-- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充-- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right joinselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id; TRUNCATE123456789/* TRUNCATE */ ------------------TRUNCATE [TABLE] tbl_name清空数据删除重建表区别：1，truncate 是删除表再创建，delete 是逐条删除2，truncate 重置auto_increment的值。而delete不会3，truncate 不知道删除了几条，而delete知道。4，当被用于带分区的表时，truncate 会保留分区 备份与还原123456789101112131415161718192021/* 备份与还原 */ ------------------备份，将数据的结构与表内数据保存起来。利用 mysqldump 指令完成。-- 导出mysqldump [options] db_name [tables]mysqldump [options] ---database DB1 [DB2 DB3...]mysqldump [options] --all--database1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)可以-w携带WHERE条件-- 导入1. 在登录mysql的情况下： source 备份文件2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 视图1234567891011121314151617181920212223242526272829什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。-- 创建视图CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过ALGORITHM指定。 - column_list如果存在，则数目必须等于SELECT语句检索的列数-- 查看结构 SHOW CREATE VIEW view_name-- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ...-- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement-- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构-- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。 事务(transaction)123456789101112131415161718192021222324252627282930313233343536373839404142434445事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续SQL的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 - InnoDB被称为事务安全型引擎。-- 事务开启 START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。-- 事务提交 COMMIT;-- 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。-- 事务的特性 1. 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（Consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。-- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。-- 事务的原理 利用InnoDB的自动提交(autocommit)特性完成。 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。-- 注意 1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套-- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点-- InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) 锁表1234567/* 锁表 */表锁定只用于防止其它客户端进行不正当地读取和写入MyISAM 支持表锁，InnoDB 支持行锁-- 锁定 LOCK TABLES tbl_name [AS alias]-- 解锁 UNLOCK TABLES 触发器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 触发器 */ ------------------ 触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象 监听：记录的增加、修改、删除。-- 创建触发器CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 INSERT：将新行插入表时激活触发程序 UPDATE：更改某一行时激活触发程序 DELETE：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构-- 删除DROP TRIGGER [schema_name.]trigger_name可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new.-- 注意 1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。-- 字符连接函数concat(str1,str2,...])concat_ws(separator,str1,str2,...)-- 分支语句if 条件 then 执行语句elseif 条件 then 执行语句else 执行语句end if;-- 修改最外层语句结束符delimiter 自定义结束符号 SQL语句自定义结束符号delimiter ; -- 修改回原来的分号-- 语句块包裹begin 语句块end-- 特殊的执行1. 只要添加记录，就会触发程序。2. Insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert SQL编程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/* SQL编程 */ --------------------// 局部变量 ------------ 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。-- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量）--// 全局变量 ------------ 定义、赋值set 语句可以定义并为变量赋值。set @var = value;也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。select @var:=20;select @v1:=id, @v2=name from t1 limit 1;select * from tbl_name where @var:=30;select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb;-- 自定义变量名为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。@var=10; - 变量被定义后，在整个会话周期都有效（登录到退出）--// 控制结构 ------------ if语句if search_condition then statement_list [elseif search_condition then statement_list]...[else statement_list]end if;-- case语句CASE value WHEN [compare-value] THEN result[WHEN [compare-value] THEN result ...][ELSE result]END-- while循环[begin_label:] while search_condition do statement_listend while [end_label];- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环--// 内置函数 ------------ 数值函数abs(x) -- 绝对值 abs(-10.9) = 10format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46ceil(x) -- 向上取整 ceil(10.1) = 11floor(x) -- 向下取整 floor (10.1) = 10round(x) -- 四舍五入去整mod(m, n) -- m%n m mod n 求余 10%3=1pi() -- 获得圆周率pow(m, n) -- m^nsqrt(x) -- 算术平方根rand() -- 随机数truncate(x, d) -- 截取d位小数-- 时间日期函数now(), current_timestamp(); -- 当前日期时间current_date(); -- 当前日期current_time(); -- 当前时间date(&apos;yyyy-mm-dd hh:ii:ss&apos;); -- 获取日期部分time(&apos;yyyy-mm-dd hh:ii:ss&apos;); -- 获取时间部分date_format(&apos;yyyy-mm-dd hh:ii:ss&apos;, &apos;%d %y %a %d %m %b %j&apos;); -- 格式化时间unix_timestamp(); -- 获得unix时间戳from_unixtime(); -- 从时间戳获得时间-- 字符串函数length(string) -- string长度，字节char_length(string) -- string的字符个数substring(str, position [,length]) -- 从str的position开始,取length个字符replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_strinstr(string ,substring) -- 返回substring首次在string中出现的位置concat(string [,...]) -- 连接字串charset(str) -- 返回字串字符集lcase(string) -- 转换成小写left(string, length) -- 从string2中的左边起取length个字符load_file(file_name) -- 从文件读取内容locate(substring, string [,start_position]) -- 同instr,但可指定开始位置lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为lengthltrim(string) -- 去除前端空格repeat(string, count) -- 重复count次rpad(string, length, pad) --在str后用pad补充,直到长度为lengthrtrim(string) -- 去除后端空格strcmp(string1 ,string2) -- 逐字符比较两字串大小-- 流程函数case when [condition] then result [when [condition] then result ...] [else result] end 多分支if(expr1,expr2,expr3) 双分支。-- 聚合函数count()sum();max();min();avg();group_concat()-- 其他常用函数md5();default();--// 存储函数，自定义函数 ------------ 新建 CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。-- 删除 DROP FUNCTION [IF EXISTS] function_name;-- 查看 SHOW FUNCTION STATUS LIKE &apos;partten&apos; SHOW CREATE FUNCTION function_name;-- 修改 ALTER FUNCTION function_name 函数选项--// 存储过程，自定义功能 ------------ 定义存储存储过程 是一段代码（过程），存储在数据库中的sql组成。一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。-- 创建CREATE PROCEDURE sp_name (参数列表) 过程体参数列表：不同于函数的参数列表，需要指明参数类型IN，表示输入型OUT，表示输出型INOUT，表示混合型注意，没有返回值。 存储过程12345678910111213141516/* 存储过程 */ ------------------存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。调用：CALL 过程名-- 注意- 没有返回值。- 只能单独调用，不可夹杂在其他语句中-- 参数IN|OUT|INOUT 参数名 数据类型IN 输入：在调用过程中，将数据输入到过程体内部的参数OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端INOUT 输入输出：既可输入，也可输出-- 语法CREATE PROCEDURE 过程名 (参数列表)BEGIN 过程体END 用户和权限管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* 用户和权限管理 */ -------------------- root密码重置1. 停止MySQL服务2. [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [Windows] mysqld --skip-grant-tables3. use mysql;4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;5. FLUSH PRIVILEGES;用户信息表：mysql.user-- 刷新权限FLUSH PRIVILEGES;-- 增加用户CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 &apos;user_name&apos;@&apos;192.168.1.1&apos; - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD-- 重命名用户RENAME USER old_user TO new_user-- 设置密码SET PASSWORD = PASSWORD(&apos;密码&apos;) -- 为当前用户设置密码SET PASSWORD FOR 用户名 = PASSWORD(&apos;密码&apos;) -- 为指定用户设置密码-- 删除用户DROP USER 用户名-- 分配权限/添加用户GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &apos;password&apos;] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 GRANT ALL PRIVILEGES ON `pms`.* TO &apos;pms&apos;@&apos;%&apos; IDENTIFIED BY &apos;pms0817&apos;;-- 查看权限SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();-- 撤消权限REVOKE 权限列表 ON 表名 FROM 用户名REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限-- 权限层级-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。-- 权限列表ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限ALTER -- 允许使用ALTER TABLEALTER ROUTINE -- 更改或取消已存储的子程序CREATE -- 允许使用CREATE TABLECREATE ROUTINE -- 创建已存储的子程序CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLECREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。CREATE VIEW -- 允许使用CREATE VIEWDELETE -- 允许使用DELETEDROP -- 允许使用DROP TABLEEXECUTE -- 允许用户运行已存储的子程序FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILEINDEX -- 允许使用CREATE INDEX和DROP INDEXINSERT -- 允许使用INSERTLOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLESPROCESS -- 允许使用SHOW FULL PROCESSLISTREFERENCES -- 未被实施RELOAD -- 允许使用FLUSHREPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）SELECT -- 允许使用SELECTSHOW DATABASES -- 显示所有数据库SHOW VIEW -- 允许使用SHOW CREATE VIEWSHUTDOWN -- 允许使用mysqladmin shutdownSUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。UPDATE -- 允许使用UPDATEUSAGE -- “无权限”的同义词GRANT OPTION -- 允许授予权限 表维护12345678/* 表维护 */-- 分析和存储表的关键字分布ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...-- 检查一个或多个表是否有错误CHECK TABLE tbl_name [, tbl_name] ... [option] ...option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;-- 整理数据文件的碎片OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 杂项1234567891011121314/* 杂项 */ ------------------1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！2. 每个库目录存在一个保存当前数据库的选项文件db.opt。3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \&apos;5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。6. SQL对大小写不敏感7. 清除已有语句：\c]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer与StringBuilder]]></title>
    <url>%2F2019%2F08%2F12%2FString%E3%80%81StringBuilder%E4%B8%8EStringBuffer%2F</url>
    <content type="text"><![CDATA[StringString简介java中String为引用数据类型，其本身也为一个class文件，实现原理为char类型数组。（看下图）由于String类为final修饰的并且数组char value[]也为final修饰，所以String为不可变类型,赋值后不能改变，为字符串常量。 举个栗子🌰 12String a = &quot;eli&quot;;String a = &quot;chen&quot;; 以上语句看似字符串a发生了改变，从eli变为chen,但是String不可变所说的为字符串本身不可变，不是其引用所指向的对象地址。这里创建了一个新的String对象并使用a引用指向其地址，原来的eli并没有发生改变而是失去了地址引用,变成了内存中的垃圾。 String之间的比较我们在比较字符串时我们想比较的是字符串的内容是否相等，因为String为引用数据类型，String对象存储的只是指向该字符串堆空间的一个内存地址，使用==比较并不能得到正确结果，这与我们的初衷违背，因为String重写了Object类的equals()方法，我们在进行字符串比较式必须使用equals()方法，不能使用==。 代码演示 123456789101112代码段1：String str1 = &quot;aa&quot;;String str2 = &quot;aa&quot;;System.out.println(str1 == str2); //trueSystem.out.println(str1.equals(str2)); //true代码段2：String str3 = new String(&quot;cc&quot;);String str4 = new String(&quot;cc&quot;);System.out.println(str3 == str4); //falseSystem.out.println(str3.equals(str4)); //true代码段3：String e = &quot;eli&quot; + &quot;chen&quot;; 看以上代码发现str1==str2为true而str3==str4为false，原因是因为java在编译期会将相同的字符串当做一个对象放入常量池，所以str1和str2为同一个对象，==也为true。使用new String()来创建对象会强制创建两个不同的对象，所以str3==str4为false。 以上代码共创建几个对象？ 代码段1：String str1 = “aa”;在字符串常量池创建一个对象”aa”，后面str2时直接引用该对象，不用再创建，共创建一个对象 代码段2：先在字符串常量池创建一个对象”cc”,然后在堆空间创建两个对象，使str3和str4分别指向它们，共创建3个对象 代码段3:在字符串常量区创建3个对象，分别是”eli” ，“chen”，“elichen” 方法简介 判断功能 12345678910111213141516171819202122232425262728293031323334//1 equals判断字符串内容是否相等 引用数据类型 ==比较的是内存地址（是不是同一个对象）String s1 = &quot;aaa&quot;;String s2 = new String(&quot;aaa&quot;);System.out.println(s1.equals(s2)); //常量和变量使用equals比较内容时，尽量把常量写在前面//equalsIgnoreCase 忽略大小写的比较String str1 = &quot;aaa&quot;;String str2 = &quot;AAA&quot;;System.out.println(str1.equals(str2));System.out.println(str1.equalsIgnoreCase(str2));//contains 判断字符串是否包含某内容(子串)String str = &quot;abcde&quot;;System.out.println(str.contains(&quot;ab&quot;));System.out.println(str.contains(&quot;cde&quot;));System.out.println(str.contains(&quot;ac&quot;)); // startsWith endsWith 判断字符串是否以某个值开头 是否以某个值结尾String str=&quot;http://www.sina.com.cn&quot;;System.out.println(str.startsWith(&quot;h&quot;));System.out.println(str.startsWith(&quot;http&quot;));System.out.println(str.endsWith(&quot;cn&quot;));System.out.println(str.endsWith(&quot;.cn&quot;));// isEmpty 判断字符串是否 为空串String str1 = &quot;&quot;;String str2 = new String();String str3 = new String(&quot;&quot;);String str4 = &quot; &quot;;System.out.println(str1.isEmpty());System.out.println(str2.isEmpty());System.out.println(str3.isEmpty());System.out.println(str4.isEmpty()); 获取功能 1234567891011121314151617181920212223242526272829303132333435// 1 length() 获取字符串长度（由多少个字符组成）String str = &quot;abc&quot;;int x = str.length();System.out.println(x); //2 charAt 获取某个位置上的字符String str = &quot;abcde&quot;;char c = str.charAt(1);System.out.println(c); //3 substring 截取子串String str = &quot;abcdefg&quot;;String result = str.substring(2); //取到最后System.out.println(result);String result2 = str.substring(2,4); // 左闭右开System.out.println(result2); //4 indexOf 查找位置String str = &quot;abcdeabcd&quot;;int idx = str.indexOf(&quot;cd&quot;);System.out.println(idx); int idx2 = str.indexOf(&quot;ab&quot;,3);//int idx2 = str.indexOf(&quot;ab&quot;,-3);// 第2个参数为负数，相当于0System.out.println(idx2);int idx3 = str.indexOf(&quot;xy&quot;);System.out.println(idx3); // 找不到时，返回-1//5 lastIndexOf 查找位置 从后向前找String str = &quot;abcdeabcd&quot;;int idx = str.lastIndexOf(&quot;cd&quot;);System.out.println(idx); int idx2 = str.lastIndexOf(&quot;ab&quot;,3);System.out.println(idx2); int idx3 = str.lastIndexOf(&quot;xy&quot;);System.out.println(idx3); // 找不到时，返回-1 转换功能 12345678910111213141516171819202122232425262728293031323334353637// 1 getBytes() 将字符串转换成字节数组String str = &quot;abcd&quot;;byte[] b = str.getBytes();for(byte bb:b)&#123; System.out.println(bb);&#125;// 2 toCharArray() 将字符串转成字符数组String str = &quot;abcd&quot;;char[] cc = str.toCharArray();for(char c:cc)&#123; System.out.println(c);&#125;// 3 toUpperCase 小写转大写String str = &quot;abcd&quot;;String str2 = str.toUpperCase();System.out.println(str2); //4 toLowerCase 大写转小写String str = &quot;AbCd&quot;;String str2 = str.toLowerCase();System.out.println(str2); //5 concat 用来拼接字符串 和 +的作用相同 . 不同点： + 可以加任何类型 而concat只能拼接字符串String s1 = &quot;aaa&quot;;String s2 = &quot;bbb&quot;;String s3= s1.concat(s2);System.out.println(s3); //6 valueOf 将其他类型转换成字符串 静态方法 int x = 100;String str = String.valueOf(x);System.out.println(str+1); // &quot;1001&quot;int y = 200;String str2 = y+&quot;&quot;; //任何类型和字符串相加结果都是字符串System.out.println(str2+1); //&quot;2001&quot; StringBuffer(JDK1.0)StringBuffer简介StringBuffer为可变长字符串，原理与字符串相同，数组为可变长数组，默认容量为16，创建更长的字符串可以自动扩容。StringBuffer对象可以被多次修改并不会产生新的对象,进行字符串处理效率高。StringBuffer的方法都是使用synchronized修饰的方法，所以StringBuffer为线程安全的。 StringBuffer方法简介12345678910111213141516171819202122232425262728293031323334353637//StringBuffer构造方法1StringBuffer sb1=new StringBuffer(&quot;Hello&quot;);System.out.println(sb1); String s1=&quot;World&quot;;//StringBuffer构造方法2StringBuffer sb2=new StringBuffer(s1);System.out.println(sb2); //length()返回字符串的长度System.out.println(sb2.length());//toString()这个方法重写了Object中的toString()方法，返回String类型的字符串//输出StringBuffer对象时候，会默认调用此方法System.out.println(sb2); //append(String s)方法在原有的字符串后面添加字符串,返回的是添加后的StringBuffer对象sb1.append(&quot; World&quot;);System.out.println(sb1); //public StringBuffer deleteCharAt(int index)//该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串sb1.deleteCharAt(0);System.out.println(sb1);//ello World //public StringBuffer delete(int start,int end)//从字符缓冲区中从start索引删除到end索引所对应的字符，其中包括start索引不包括end索引对应的值sb1.delete(1, 3);System.out.println(sb1); //public StringBuffer insert(int offset,String str)//在字符串缓冲区的第offset个字符后面插入指定字符串sb1.insert(1, &quot;ME&quot;);System.out.println(sb1); //public StringBuffer reverse(),将字符串反转sb1.reverse();System.out.println(sb1); StringBuilder(JDK1.5)StringBuilder简介StringBuilder在JDK5.0新增的，StringBuilder与StringBuffer基本相同只不过不是线程安全的，方法也大致相同。StringBuilder效率更高。 总结执行速度 三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String线程安全 StringBuffer：线程安全的，StringBuilder：非线程安全的 使用策略 1.如果要操作少量的数据用String 2.单线程操作字符串缓冲区 下操作大量数据用StringBuilder 3.多线程操作字符串缓冲区 下操作大量数据用StringBuffer 4.不要使用String类的”+”来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java包装类]]></title>
    <url>%2F2019%2F08%2F11%2Fjava%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[浅谈Java包装类为什么会有包装类，包装类是什么？Java语言一直宣称自己是完全面向对象的语言，但对于基本数据类型并没有做到面向对象。为解决这一个问题Java提供了基本数据类型对应的包装类。 如下表 基本数据类型 包装类型 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 包装类继承结构图 包装类的作用 集合不允许存放基本数据类型，故常用包装类 包含了每种基本数据类型的相关属性，如最大值、最小值、所占位数等 作为基本数据类型对应的类类型，提供了一系列实用的对象操作，如类型转换、进制转换等等 123456789101112131415161718192021222324252627282930313233private static void getInfo() &#123; //获取基本数据类型的相关属性 System.out.println(Byte.MIN_VALUE);//-128 System.out.println(Byte.MAX_VALUE);//127 System.out.println(Byte.SIZE);//8 /* * 包装类型的一些实用操作，如类型转换、进制转换等 * 这里以Integer为例，主要介绍intValue、（static）parseInt、（static）toString等方法 */ //调用构造器将int类型转换为integer类型，调用intValue方法将integer类型转换为int类型 Integer in1 = new Integer(100); int in2 = in1.intValue(); //将字符串转换为十进制数的int数，常用于任意进制数转换为十进制数 int num1 = Integer.parseInt(&quot;100&quot;); System.out.println(num1); //100 //将字符串按任意进制转换为int数 int num2 = Integer.parseInt(&quot;100&quot;, 8); int num3 = Integer.parseInt(&quot;ff&quot;, 16); System.out.println(num2); //64 System.out.println(num3); //将int数转换为对应的String类型的数 String s1 = Integer.toString(100); System.out.println(s1);//100 //将int数转换为任意进制的String类型的数，常用于十进制数转换为任意进制数 String s2 = Integer.toString(100,8); String s3 = Integer.toString(100,16); System.out.println(s2);//144 System.out.println(s3);//64&#125; 那么，如何把一个基本类型转化为包装类型？ 123456789101112public class Main &#123; public static void main(String[] args) &#123; int i = 100; // 通过new操作符创建Integer实例(不推荐使用,会有编译警告): Integer n1 = new Integer(i); // 通过静态方法valueOf(int)创建Integer实例: Integer n2 = Integer.valueOf(i); // 通过静态方法valueOf(String)创建Integer实例: Integer n3 = Integer.valueOf(&quot;100&quot;); System.out.println(n3.intValue()); &#125;&#125; 自动装箱与拆箱(Autoboxing and unboxing)从JDK1.5就开始引入了自动拆装箱的语法功能，也就是系统将自动进行基本数据类型和与之相对应的包装类型之间的转换，这使得程序员书写代码更加方便。 因为int和Integer可以互相转换： 123int i = 100;Integer n = Integer.valueOf(i);int x = n.intValue(); 所以，Java编译器可以帮助我们自动在int和Integer之间转型： 12Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue() 这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。 注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。 装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException： 1234567// NullPointerExceptionpublic class Main &#123; public static void main(String[] args) &#123; Integer n = null; int i = n; &#125;&#125; 包装类型之间的判断对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较： 1234567891011// == or equals?public static void main(String[] args) &#123; Integer x = 66; Integer y = 66; Integer m = 666; Integer n = 666; System.out.println(&quot;x == y: &quot; + (x == y)); System.out.println(&quot;m == n: &quot; + (m == n)); System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); System.out.println(&quot;m.equals(n): &quot; + m.equals(n));&#125; 结果为 1234x == y: truem == n: falsex.equals(y): truem.equals(n): true 因为包装类重写了Object的equals()方法，这里的equals() 比较的是两个对象的值（内容）是否相同。所以equals()方法比较的结果都为true “==” 比较的是两个对象的引用（内存地址）是否相同，也用来比较两个基本数据类型的变量值是否相等。那么为什吗66的包装类用”==”比较是true而666的包装类使用”==”比较结果为false？ int 的自动装箱，是系统执行了 Integer.valueOf(int i)，先看看Integer.java的源码： 123456789101112131415161718192021222324252627282930313233343536373839private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125;public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 对于–128到127（默认是127）之间的值，Integer.valueOf(int i)返回的是缓存的Integer对象（并不是新建对象） 所以，x 与 y实际上是指向同一个对象。 而其他值，执行Integer.valueOf(int i) 返回的是一个新建的 Integer对象，所以范例中，m与 n 指向的是不同的对象。 当然，当不使用自动装箱功能的时候，情况与普通类对象一样 1234Integer x = new Integer(66);Integer y = new Integer(66);System.out.println(&quot;x == y: &quot; + (x == y));System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); 结果为 12x == y: falsex.equals(y): true 所以包装类在比较时都应使用equals()方法在我们自己创建Integer的时候尽量使用Integer.valueOf(int i)方法，它尽可能地返回缓存的实例以节省内存。]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java常用工具类]]></title>
    <url>%2F2019%2F08%2F10%2Fjava%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[java常用工具类Math类顾名思义，math为数学，Math类为java提供的数学计算相关的类库。Math类中的方法都为静态方法，直接使用类名调用。 常用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static void main(String[] args) &#123; //常数π System.out.println(Math.PI); //3.141592653589793 // 产生一个[0,1)的随机数 double random = Math.random(); System.out.println(random); //0.4529940913667322 //绝对值 int abs = Math.abs(5); int abs2 = Math.abs(-5); System.out.println(abs + &quot; &quot; + abs2); //5 5 //立方根 double cbrt = Math.cbrt(27); System.out.println(cbrt); //3.0 //平方根 double sqrt = Math.sqrt(16); System.out.println(sqrt); //4.0 //天花板数 大于它的最小的整数 double ceil = Math.ceil(4.5); System.out.println(ceil); //5.0 //地板数 小于它的最大的整数 double floor = Math.floor(4.5); System.out.println(floor); //4.0 //最大值 最小值 int max = Math.max(10, 8); //10 int min = Math.min(10, 8); //8 int x = 11; int y = 8; int z = 5; int result = Math.max(Math.max(x, y), z); System.out.println(result); //11 // 四舍五入取整数 long round = Math.round(4.4); System.out.println(round); //4&#125; 如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现，计算如下： 123456789101112// 区间在[MIN, MAX)的随机数public class Main &#123; public static void main(String[] args) &#123; double x = Math.random(); // x的范围是[0,1) double min = 10; double max = 50; double y = x * (max - min) + min; // y的范围是[10,50) long n = (long) y; // n的范围是[10,50)的整数 System.out.println(y); System.out.println(n); &#125;&#125; Random类相对于Math的random方法只能生产 0 到 1之间的随机数 Java提供了一个功能更强大的随机数生产类 Random类,Random用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。 nextBoolean() 随机生产true 或false nextDouble() 随机生产 0 到1 之间的随机浮点数 nextFloat()随机生产 0 到1 之间的随机浮点数 nextInt()随机生产整数 nextLong() 随机生产整数 nextInt(n) 随机生产 0 到 n之间的整数全部都是左闭右开区间 代码演示 12345678910111213141516171819public static void main(String[] args) &#123; Random r = new Random(); boolean b =r.nextBoolean(); System.out.println(b); double d = r.nextDouble(); //[0.1) System.out.println(d); int x = r.nextInt(); System.out.println(x); int y = r.nextInt(100); System.out.println(y); long z = r.nextLong(); System.out.println(z); &#125; SecureRandom有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的： 12SecureRandom sr = new SecureRandom();System.out.println(sr.nextInt(100)); SecureRandom无法指定种子，它使用RNG（random number generator）算法。JDK的SecureRandom实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器： 12345678910111213141516import java.util.Arrays;import java.security.SecureRandom;import java.security.NoSuchAlgorithmException;public class Main &#123; public static void main(String[] args) &#123; SecureRandom sr = null; try &#123; sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器 &#125; catch (NoSuchAlgorithmException e) &#123; sr = new SecureRandom(); // 获取普通的安全随机数生成器 &#125; byte[] buffer = new byte[16]; sr.nextBytes(buffer); // 用安全随机数填充buffer System.out.println(Arrays.toString(buffer)); &#125;&#125; SecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。 在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。 需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>java常用类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java常用类之BigDecimal]]></title>
    <url>%2F2019%2F08%2F09%2Fjava%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B9%8BBigDecimal%2F</url>
    <content type="text"><![CDATA[BigDecimal小数计算丢失精度问题在计算机中，所有文件都是以二进制存储的，数字运算也是使用二进制进行计算的，因为计算机中不存在小数点，所以我们通常说的浮点数如float、double都是计算机使用二进制模拟出来的，但我们在计算机中运行以下代码获得的结果并不是正确的。 12345double a = 0.1;double b = 0.3;System.out.println(b-a);// 结果为0.19999999999999998 为什么呢？我们先来看十进制小数如何转化为二进制数的 二进制小数 0.1111 12345第一位1表示十进制1/2第二位1表示十进制1/4第三位1表示十进制1/8第四位1表示十进制1/16...... 所以十进制小数转二进制小数，算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数 123456780.9*2=1.8 取整数部分 10.8(1.8的小数部分)*2=1.6 取整数部分 10.6*2=1.2 取整数部分 10.2*2=0.4 取整数部分 00.4*2=0.8 取整数部分 00.8*2=1.6 取整数部分 10.6*2=1.2 取整数部分 0......... 0.9二进制表示为(从上往下): 1100100100100...... 注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了”减不尽”的精度丢失问题。 BigDecimal简介因为丢失精度问题，所以java引入了BigDecimal类来解决这一问题。 BigDecimal 由任意精度的整数非标度值 和32 位的整数标度 (scale) 组成。如果为零或正数，则标度是小数点后的位数。如果为负数，则将该数的非标度值乘以 10 的负scale 次幂。因此，BigDecimal表示的数值是(unscaledValue × 10-scale)。 BigDecimal函数介绍构造函数构造函数如下 我们使用参数为double的构造方法创建对象，并打印输出代码如下 1234BigDecimal b1 =new BigDecimal(0.1);System.out.println(b1);//结果为0.1000000000000000055511151231257827021181583404541015625 我们期望的结果为0.1，可是结果还是损失精度的。难道BigDecimal没用吗？ 使用下面方式声明BigDecimal时，会出现精度问题 1BigDecimal b = new BigDecimal(0.1); 推荐用法 12BigDecimal bd1 = new BigDecimal(&quot;0.1&quot;);BigDecimal bd2 = BigDecimal.valueOf(0.1); 用以上方法就不会出问题精度问题BigDecimal.valueOf() 查看源码就可以知道，也是使用的new BigDecimal(“0.1”)构造函数 JDK的描述：1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入new BigDecimal(0.1)所创建的BigDecimal正好等于 0.1(非标度值 1，其标度为 1)，但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double(或者说对于该情况，不能表示为任何有限长度的二进制小数)。这样，传入到构造方法的值不会正好等于 0.1(虽然表面上等于该值)。 2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。 3、当double必须用作BigDecimal的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用Double.toString(double)方法，然后使用BigDecimal(String)构造方法，将double转换为String。要获取该结果，请使用static valueOf(double)方法。 常用方法 1.BigDecimal(String val)：构造方法，将String类型转换成BigDecimal类型数据。 2.BigDecimal(double val)：构造方法，将double类型转换成BigDecimal类型数据。 3.BigDecimal(int val)：构造方法，将int类型转换成BigDecimal类型数据。 4.BigDecimal add(BigDecimal value)：加法，求两个BigDecimal类型数据的和。 5.BigDecimal subtract(BigDecimal value)：减法，求两个BigDecimal类型数据的差。 6.BigDecimal multiply(BigDecimal value)：乘法，求两个BigDecimal类型数据的积。 7.BigDecimal divide(BigDecimal divisor)：除法，求两个BigDecimal类型数据的商。 8.BigDecimal remainder(BigDecimal divisor)：求余数，求BigDecimal类型数据除以divisor的余数。 9.BigDecimal max(BigDecimal value)：最大数，求两个BigDecimal类型数据的最大值。 10.BigDecimal min(BigDecimal value)：最小数，求两个BigDecimal类型数据的最小值。 11.BigDecimal abs()：绝对值，求BigDecimal类型数据的绝对值。 12.BigDecimal negate()：相反数，求BigDecimal类型数据的相反数。 代码演示 1234567891011121314151617181920212223BigDecimal a=new BigDecimal (&quot;4.5&quot;);BigDecimal b=new BigDecimal (&quot;1.5&quot;);BigDecimal c=new BigDecimal (&quot;-10.5&quot;); BigDecimal add_result=a.add(b);BigDecimal subtract_result=a.subtract(b);BigDecimal multiply_result=a.multiply(b);BigDecimal divide_result=a.divide(b);BigDecimal remainder_result=a.remainder(b);BigDecimal max_result=a.max(b);BigDecimal min_result=a.min(b);BigDecimal abs_result=c.abs();BigDecimal negate_result=a.negate(); Log.d(&quot;TAG&quot;,&quot;4.5+1.5=&quot;+add_result);Log.d(&quot;TAG&quot;,&quot;4.5-1.5=&quot;+subtract_result);Log.d(&quot;TAG&quot;,&quot;4.5*1.5=&quot;+multiply_result);Log.d(&quot;TAG&quot;,&quot;4.5/1.5=&quot;+divide_result);Log.d(&quot;TAG&quot;,&quot;4.5/1.5余数=&quot;+remainder_result);Log.d(&quot;TAG&quot;,&quot;4.5和1.5最大数=&quot;+max_result);Log.d(&quot;TAG&quot;,&quot;4.5和1.5最小数=&quot;+min_result);Log.d(&quot;TAG&quot;,&quot;-10.5的绝对值=&quot;+abs_result);Log.d(&quot;TAG&quot;,&quot;4.5的相反数=&quot;+negate_result); 结果为 1234567894.5+1.5=6.04.5-1.5=3.04.5*1.5=6.754.5/1.5=34.5/1.5余数=0.04.5和1.5最大数=4.54.5和1.5最小数=1.5-10.5的绝对值=10.54.5的相反数=-4.5 BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以在做加减乘除运算时千万要保存操作后的值。 BigDecimal用scale()表示小数位数，例如： 123456BigDecimal d1 = new BigDecimal(&quot;123.45&quot;);BigDecimal d2 = new BigDecimal(&quot;123.4500&quot;);BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);System.out.println(d1.scale()); // 2,两位小数System.out.println(d2.scale()); // 4System.out.println(d3.scale()); // 0 通过BigDecimal的stripTrailingZeros()方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal： 123456789BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;);BigDecimal d2 = d1.stripTrailingZeros();System.out.println(d1.scale()); // 4System.out.println(d2.scale()); // 2,因为去掉了00BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);BigDecimal d4 = d1.stripTrailingZeros();System.out.println(d3.scale()); // 0System.out.println(d4.scale()); // -2 如果一个BigDecimal的scale()返回负数，例如，-2，表示这个数是个整数，并且末尾有2个0。 可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断： 123456789public class Main &#123; public static void main(String[] args) &#123; BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;); BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568 BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567 System.out.println(d2); System.out.println(d3); &#125;&#125; 对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断： 123BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;);BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入 在比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等： 12345BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);BigDecimal d2 = new BigDecimal(&quot;123.45600&quot;);System.out.println(d1.equals(d2)); // false,因为scale不同System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2System.out.println(d1.compareTo(d2)); // 0 必须使用compareTo()方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！ 如果查看BigDecimal的源码，可以发现，实际上一个BigDecimal是通过一个BigInteger和一个scale来表示的，即BigInteger表示一个完整的整数，而scale表示小数位数： 1234public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; &#123; private final BigInteger intVal; private final int scale;&#125; BigDecimal也是从Number继承的，也是不可变对象。 源码分析为什么BigDecimal使用String不会出现精度问题现在我们明白为什么用double,float 出现出精度问题。现在我们要看一下BigDecimal对String做了什么不会出现精度问题 通过Debug构造方法，我们可以了解，BigDecimal底层数据结构主要是由下面四个属性值组成. 1234int scale; //有多少位小数(即小数点后有多少位)int precision; //总工有多少位数字long intCompact; //字符串去掉小数点后，转为long的值，只有当传的字符串长度小于18时才使用该言BigInteger intVal; //当传的字符串长度大于等于18时才使用BigInteger表示数字 以new BigDecimal(&quot;12.12&quot;)为例 12345scale值为2precision值为4intCompact值为1212intVal值为空。之所以为空是因为字符串长度没有超18位，所以不启用BigInteger表示 看到这进而其实大家应该明白了，BigDecimal将String转为了long或BigInteger来进行计算。 valueOf(doubleval)方法 valueOf实际上是调用相应包装类的toString方法然后使用BigDecimal的参数为String的构造方法创建对象。 add(BigDecimal augend)方法123456789101112131415161718192021222324252627282930313233public BigDecimal add(BigDecimal augend) &#123; long xs = this.intCompact; //整型数字表示的BigDecimal,例a的intCompact值为122 long ys = augend.intCompact;//同上 BigInteger fst = (this.intCompact != INFLATED) ? null : this.intVal;//初始化BigInteger的值，intVal为BigDecimal的一个BigInteger类型的属性 BigInteger snd = (augend.intCompact != INFLATED) ? null : augend.intVal; int rscale = this.scale;//小数位数 long sdiff = (long) rscale - augend.scale;//小数位数之差 if (sdiff != 0) &#123;//取小数位数多的为结果的小数位数 if (sdiff &lt; 0) &#123; int raise = checkScale(-sdiff); rscale = augend.scale; if (xs == INFLATED || (xs = longMultiplyPowerTen(xs, raise)) == INFLATED) fst = bigMultiplyPowerTen(raise); &#125; else &#123; int raise = augend.checkScale(sdiff); if (ys == INFLATED || (ys = longMultiplyPowerTen(ys, raise)) == INFLATED) snd = augend.bigMultiplyPowerTen(raise); &#125; &#125; if (xs != INFLATED &amp;&amp; ys != INFLATED) &#123; long sum = xs + ys; if ((((sum ^ xs) &amp; (sum ^ ys))) &gt;= 0L)//判断有无溢出 return BigDecimal.valueOf(sum, rscale);//返回使用BigDecimal的静态工厂方法得到的BigDecimal实例 &#125; if (fst == null) fst = BigInteger.valueOf(xs);//BigInteger的静态工厂方法 if (snd == null) snd = BigInteger.valueOf(ys); BigInteger sum = fst.add(snd); return (fst.signum == snd.signum) ? new BigDecimal(sum, INFLATED, rscale, 0) : new BigDecimal(sum, compactValFor(sum), rscale, 0);//返回通过其他构造方法得到的BigDecimal对象 &#125; 以上只是对加法源码的分析，减乘除其实最终都返回的是一个新的BigDecimal对象，因为BigInteger与BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以a.add(b);虽然做了加法操作，但是a并没有保存加操作后的值，正确的用法应该是a=a.add(b); 总结(1)商业计算使用BigDecimal。 (2)尽量使用参数类型为String的构造函数。 (3) BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以在做加减乘除运算时千万要保存操作后的值。 (4)我们往往容易忽略JDK底层的一些实现细节，导致出现错误，需要多加注意。 参考内容：赵勇文 ,jackiehff ,廖雪峰的官方网站。]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>java常用类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之冒泡排序]]></title>
    <url>%2F2019%2F08%2F09%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序是一种基于交换的排序算法，没两个相邻的数据元素比较，并按照想要获得的顺序进行交换位置。 算法原理冒泡排序算法的原理如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 算法过程演示对数组A={14,5,16,4,7}从小到大进行排序，冒泡排序的过程如下： 第一次遍历 第二次遍历 第三次遍历 最后一次遍历 算法分析时间复杂度在设置标志变量之后： 1.当原始序列“正序”排列时，冒泡排序总的比较次数为n-1，移动次数为0，也就是说冒泡排序在最好情况下的时间复杂度为O(n)； 2.当原始序列“逆序”排序时，冒泡排序总的比较次数为n(n-1)/2，移动次数为3n(n-1)/2次，所以冒泡排序在最坏情况下的时间复杂度为O(n^2)； 3.当原始序列杂乱无序时，冒泡排序的平均时间复杂度为O(n^2)。 空间复杂度冒泡排序排序过程中需要一个临时变量进行两两交换，所需要的额外空间为1，因此空间复杂度为O(1)。 ###稳定性冒泡排序在排序过程中，元素两两交换时，相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 Java版代码实现1234567891011void bubble_sort(int arr[], int len) &#123; int i, j, temp = 0; for (i = 0; i &lt; len - 1; i++) &#123; // 外层循环控制趟数，总趟数为len-1 for (j = 0; j &lt; len - 1 - i; j++) &#123; // 内层循环为当前i趟数 所需要比较的次数 if (arr[j] &gt; arr[j + 1]) temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架]]></title>
    <url>%2F2019%2F07%2F31%2Fjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Java集合框架集合与框架集合Java中集合就如一个容器(Container)，集合中可以存放各种对象，集合本身也是一个对象。 集合框架那么有了集合的概念，什么是集合框架呢？集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。 接口：即表示集合的抽象数据类型。接口提供了让我们对集合中所表示的内容进行单独操作的可能。 实现：也就是集合框架中接口的具体实现。实际它们就是那些可复用的数据结构。 算法：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。 集合框架结构集合框架总体结构图 从图中可以看出，Java集合框架主要包括两种类型的容器，一种是集合(Collection),存储一个元素集合，另一种是图(Map)，存储键值对映射。Collection接口有三个子类型，List，Set，Quee，接着是一些抽象类，最后是具体的实现类，常用的类有ArrayList，HashSet，LinkedHashSet、HashMap、LinkedHashMap 等等。 除了集合，该框架也定义了几个Map接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。 Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。 常见接口及实现类Collection接口该接口为集合类的顶级父类该类中的方法（来源于API）如下 Set类Set集合与Collection的方法相同，由于Set集合不允许存储相同的元素，所以如果把两个相同元素添加到同一个Set集合，则添加操作失败，新元素不会被加入，add()方法返回false。 代码示例： 12345678910public class Test &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;hello world&quot;); set.add(&quot;hello elichen&quot;); set.add(&quot;hello elichen&quot;);//添加不进去 System.out.println(&quot;集合中元素个数：&quot;+set.size()); System.out.println(&quot;集合中元素为：&quot;+set.toString()); &#125;&#125; 运行结果如下： 12集合中元素个数：2集合中元素为：[hello world, hello elichen] 由于String类中重写了hashCode()和equals()方法，用来比较指向的字符串对象所存储的字符串是否相等。所以这里的第二个”hello elichen”是加不进去的。 HashSet类HashSet是Set集合最常用实现类。HashSet是按照hash算法来存储元素的，因此具有很好的存取和查找性能。 HashSet具有如下特点： 不能保证元素的顺序。 HashSet不是线程同步的，如果多线程操作HashSet集合，则应通过代码来保证其同步。 集合元素值可以是null。 HashSet存储原理如下： 当向HashSet集合存储一个元素时，HashSet会调用该对象的hashCode()方法得到其hashCode值，然后根据hashCode值决定该对象的存储位置。HashSet集合判断两个元素相等的标准是(1)两个对象通过equals()方法比较返回true；(2)两个对象的hashCode()方法返回值相等。因此，如果(1)和(2)有一个不满足条件，则认为这两个对象不相等，可以添加成功。如果两个对象的hashCode()方法返回值相等，但是两个对象通过equals()方法比较返回false，HashSet会以链式结构将两个对象保存在同一位置，这将导致性能下降，因此在编码时应避免出现这种情况。 HashSet查找原理如下： 基于HashSet以上的存储原理，在查找元素时，HashSet先计算元素的HashCode值（也就是调用对象的hashCode方法的返回值），然后直接到hashCode值对应的位置去取出元素即可，这就是HashSet速度很快的原因。 重写hashCode()方法的基本原则如下： 在程序运行过程中，同一个对象的hashCode()方法返回值应相同。 当两个对象通过equals()方法比较返回true时，这两个对象的hashCode()方法返回值应该相等。 对象中用作equals()方法比较标准的实例变量，都应该用于计算hashCode值。 LinkedHashSet类LinkedHashSet是HashSet的一个子类，具有HashSet的特性，也是根据元素的hashCode值来决定元素的存储位置。但它使用链表维护元素的次序，元素的顺序与添加顺序一致。由于LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet，但在迭代访问Set里的全部元素时由很好的性能。 TreeSet类TreeSet时SortedSet接口的实现类，TreeSet可以保证元素处于排序状态，它采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方法：自然排序和定制排序，默认采用自然排序。 自然排序 TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素的大小关系，然后将元素按照升序排列，这就是自然排序。如果试图将一个对象添加到TreeSet集合中，则该对象必须实现Comparable接口，否则会抛出异常。当一个对象调用方法与另一个对象比较时，例如obj1.compareTo(obj2)，如果该方法返回0，则两个对象相等；如果返回一个正数，则obj1大于obj2；如果返回一个负数，则obj1小于obj2。 Java常用类中已经实现了Comparable接口的类有以下几个： BigDecimal、BigDecimal以及所有数值型对应的包装类：按照它们对应的数值大小进行比较。 Charchter：按照字符的unicode值进行比较。 Boolean：true对应的包装类实例大于false对应的包装类实例。 String：按照字符串中的字符的unicode值进行比较。 Date、Time：后面的时间、日期比前面的时间、日期大。 对于TreeSet集合而言，它判断两个对象是否相等的标准是：两个对象通过compareTo(Object obj)方法比较是否返回0，如果返回0则相等。 定制排序 想要实现定制排序，需要在创建TreeSet集合对象时，提供一个Comparator对象与该TreeSet集合关联，由Comparator对象负责集合元素的排序逻辑。 综上：自然排序实现的是Comparable接口，定制排序实现的是Comparator接口。 EnumSet类EnumSet是一个专为枚举类设计的集合类，不允许添加null值。EnumSet的集合元素也是有序的，它以枚举值在Enum类内的定义顺序来决定集合元素的顺序。 各Set实现类的性能分析HashSet的性能比TreeSet的性能好（特别是添加，查询元素时），因为TreeSet需要额外的红黑树算法维护元素的次序，如果需要一个保持排序的Set时才用TreeSet，否则应该使用HashSet。 LinkedHashSet是HashSet的子类，由于需要链表维护元素的顺序，所以插入和删除操作比HashSet要慢，但遍历比HashSet快。 EnumSet是所有Set实现类中性能最好的，但它只能 保存同一个枚举类的枚举值作为集合元素。 以上几个Set实现类都是线程不安全的，如果多线程访问，必须手动保证集合的同步性 List类List集合代表一个有序、可重复集合，集合中每个元素都有其对应的顺序索引。List集合默认按照元素的添加顺序设置元素的索引，可以通过索引（类似数组的下标）来访问指定位置的集合元素。 实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 ArrayListArrayList是一个动态数组，也是我们最常用的集合，是List类的典型实现。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。ArrayList擅长于随机访问。同时ArrayList是非同步的。 LinkedListLinkedList是List接口的另一个实现，除了可以根据索引访问集合元素外，LinkedList还实现了Deque接口，可以当作双端队列来使用，也就是说，既可以当作“栈”使用，又可以当作队列使用。 LinkedList的实现机制与ArrayList的实现机制完全不同，ArrayLiat内部以数组的形式保存集合的元素，所以随机访问集合元素有较好的性能；LinkedList内部以链表的形式保存集合中的元素，所以随机访问集合中的元素性能较差，但在插入删除元素时有较好的性能。 Vector与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。 StackStack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 Iterator接口和ListIterator接口Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口如下： boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。 Object next()：返回集合里下一个元素。 void remove()：删除集合里上一次next方法返回的元素。 ListIterator接口继承Iterator接口，提供了专门操作List的方法。ListIterator接口在Iterator接口的基础上增加了以下几个方法： boolean hasPrevious()：判断集合里是否存在上一个元素。如果有，该方法返回 true。 Object previous()：返回集合里上一个元素。 void add(Object o)：在指定位置插入一个元素。 以上两个接口相比较，不难发现，ListIterator增加了向前迭代的功能（Iterator只能向后迭代），ListIterator还可以通过add()方法向List集合中添加元素（Iterator只能删除元素）。 Map类Map接口采用键值对Map&lt;K,V&gt;的存储方式，保存具有映射关系的数据，因此，Map集合里保存两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value，key和value可以是任意引用类型的数据。key值不允许重复，可以为null。如果添加key-value对时Map中已经有重复的key，则新添加的value会覆盖该key原来对应的value。常用实现类有HashMap、LinkedHashMap、TreeMap等。 Map常见方法（来源于API）如下： Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。 HashMap以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 LinkedHashMapLinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。 TreeMapTreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。 自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。 定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。 TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。 如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面向对象]]></title>
    <url>%2F2019%2F07%2F26%2Fjava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[java 面向对象面向对象简介“面向对象” (英语：Object Oriented,简称OO)是一种以事物为中心的编程思想。面向对象程序设计（英语：Object-oriented programming，缩写：OOP），是一种程序开发的方法。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。 面向对象是相对于面向过程而言的（C则是一个典型的面向过程的语言），站在面向对象的角度去看问题，你则是对象的动作的指挥者。如果站在面向过程的角度去看问题，你则是动作的执行者。“面向过程”强调的是功能行为，面向过程”是一种以过程为中心的编程思想。“面向过程”他们不支持丰富的“面向对象”特性（比如继承、多态），就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向过程在这一系列工作的执行中，强调的是工作的执行。 java是完全面向对象的语言，那么什么是面向对象呢？ 举个栗子： 你饿了想去吃饭！ 基于面向过程你就是动作的执行者，首先你要出去买菜然后洗菜接着做菜最后感觉真难吃，浪费时间有没吃饱！ 基于面向对象你是动作的执行者，首先找一家餐厅然后想服务员点饭等待服务员上饭，饭上来了然后吃饭，饭好吃又节约时间。面向对象与面向过程对比 1.面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。 2.面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。 面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们我们使用的就是面向对象了。 面向过程： 优点：性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源。 缺点：不易维护、不易复用、不易扩展. 面向对象： 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 . 缺点：性能比面向过程差 面向对象的特征(1)抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。 (2)继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 (3)封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 (4) 多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 面向对象的”六原则一法则” 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。） 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。） 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。） 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基本数据类型]]></title>
    <url>%2F2019%2F07%2F16%2Fjava%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[java基本数据类型整型byte： byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short： short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s = 1000，short r = -20000。 int： int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 默认值是 0 ；例子：int a = 100000, int b = -200000。 long： long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L。 “L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。 浮点型float： float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币；例子：float f1 = 234.5f。 double： double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； 例子：double d1 = 123.4。 ###boolean： boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子： boolean one = true。 字符型char： char类型是一个单一的 16 位 Unicode 字符； 最小值是 \u0000（即为0）； 最大值是 \uffff（即为65,535）； char 数据类型可以储存任何字符；例子：char letter = &#39;A&#39;;。 面试题1 123456789101112131415161718public class Demo_面试题 &#123; public static void main(String[] args) &#123; int a = 1; short b = 2; /* b = b+a; // 编译报错 System.out.println(b); */ b+=a; // 这个不会报错，因为 +=在运算时底层会有一个强制类型转换 System.out.println(b); &#125;&#125; 面试题2 1234567891011121314151617181920public class Demo_面试题2 &#123; public static void main(String[] args) &#123; byte b1 = 1; byte b2 = 2; byte b3 = 1+2; // 在编译就直接计算结果为3 赋给了 b3 System.out.println(b3); //3 /* byte result = b1+b2; // 编译报错 在编译时，因为b1和b2都是变量，因此不能确定b1+b2的值是否超过byte的范围 System.out.println(result); */ //常量优化机制：有一些计算，非常简单，例如常量和常量的计算就非常简单，在编译阶段就可以把这些简单的运算计算完。 &#125;&#125; 交换两个变量的值 123456789101112131415161718192021222324252627public class Demo_练习_交换两个变量的值 &#123; public static void main(String[] args) &#123; int a = 5; int b = 8; System.out.println(&quot;a=&quot;+a); System.out.println(&quot;b=&quot;+b); /* int temp = 0; //空瓶 temp = a; a = b; b =temp; */ // 不允许使用第3个变量，完成交换 a = a+b; // a = 13 b = 5; b = a-b; // b = 8 a = 13 a = a-b; // a = 5 b = 8; System.out.println(&quot;a=&quot;+a); System.out.println(&quot;b=&quot;+b); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java流程控制语句]]></title>
    <url>%2F2019%2F07%2F16%2Fjava%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[java流程控制语句条件语句if语句一个 if 语句包含一个布尔表达式和一条或多条语句。语法 1234if(布尔表达式)&#123; //如果布尔表达式为true将执行的语句&#125; 如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 if 语句块后面的代码。 if…else语句if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。 语法 1234567if…else 的用法如下：if(布尔表达式)&#123; //如果布尔表达式的值为true&#125;else&#123; //如果布尔表达式的值为false&#125; if…else if…else 语句if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。 使用 if，else if，else 语句的时候，需要注意下面几点： if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。 if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。语法if…else 语法格式如下:123456789if(布尔表达式 1)&#123; //如果布尔表达式 1的值为true执行代码&#125;else if(布尔表达式 2)&#123; //如果布尔表达式 2的值为true执行代码&#125;else if(布尔表达式 3)&#123; //如果布尔表达式 3的值为true执行代码&#125;else &#123; //如果以上布尔表达式都不为true执行代码&#125; 嵌套的 if…else 语句使用嵌套的 if…else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。 语法 嵌套的 if…else 语法格式如下： 123456if(布尔表达式 1)&#123; ////如果布尔表达式 1的值为true执行代码 if(布尔表达式 2)&#123; ////如果布尔表达式 2的值为true执行代码 &#125;&#125; 你可以像 if 语句一样嵌套 else if…else。 循环语句while 循环while是最基本的循环，它的结构为： 123while( 布尔表达式 ) &#123; //循环内容&#125; 只要布尔表达式为 true，循环就会一直执行下去。 do…while 循环对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 123do &#123; //代码语句&#125;while(布尔表达式); 注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。 for循环虽然所有循环结构都可以用 while 或者 do…while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。 for循环执行的次数是在执行前就确定的。语法格式如下： 123for(初始化; 布尔表达式; 更新) &#123; //代码语句&#125; 关于 for 循环有以下几点说明： 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。 执行一次循环后，更新循环控制变量。 再次检测布尔表达式。循环执行上面的过程。 Java 增强 for 循环Java5 引入了一种主要用于数组的增强型 for 循环。 Java 增强 for 循环语法格式如下: 1234for(声明语句 : 表达式)&#123; //代码句子&#125; 声明语句 ：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 break 关键字break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。 break 跳出最里层的循环，并且继续执行该循环下面的语句。 语法break 的用法很简单，就是循环结构中的一条语句： 1break; continue 关键字continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。 在 for 循环中，continue 语句使程序立即跳转到更新语句。 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。 语法continue 就是循环体中一条简单的语句： 1continue; 假设修正法 求最大值求a,b,c三个数中的最大值。 /有a,b,c三个数字，求最大值。/ 123456789101112131415public class MaxNumber &#123; public static void main(String[] args) &#123; int a = 3; int b = 10; int c = 7; int m = a;// 假设，为真 if (b &gt; m) &#123;// 修改 m = b; &#125; if (c &gt; m) &#123;// 修改 m = c; &#125; System.out.println(m); &#125;&#125; 结果为 10 判断闰年求某一个年份是不是闰年。 /判断是否是闰年/ 1234567891011121314151617181920212223public class RunYear &#123; public static void main(String[] args) &#123;// int year = 2000;// boolean t = year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0;//可读性太差// System.out.println(t); //假设修正法 int year =2000; boolean t = false;//假设不是闰年 if(year%4==0)&#123; t=true; &#125; if(year%100==0)&#123; t=false; &#125; if(year%400==0)&#123; t=true; &#125; System.out.println(year+&quot;是否闰年：&quot;+t); &#125; &#125; 结果为 2000是否闰年：true]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫从零开始(六)]]></title>
    <url>%2F2019%2F06%2F26%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[认识HTML什么是HTMLHTML 是用来描述网页的一种语言。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 标签HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt; HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 HTML 文档 = 网页 HTML 文档描述网页 HTML 文档包含 HTML 标签和纯文本 HTML 文档也被称为网页Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容：123456789&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子解释 &lt;html&gt; 与 &lt;/html&gt; 之间的文本描述网页 &lt;body&gt; 与 &lt;/body&gt; 之间的文本是可见的页面内容 &lt;h1&gt; 与 &lt;/h1&gt; 之间的文本被显示为标题 &lt;p&gt; 与 &lt;/p&gt; 之间的文本被显示为段落 以下是常用标签及其含义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;style&gt; #div1 &#123; color: brown; &#125; .div2 &#123; color: chartreuse; &#125; div &#123; color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt;span标签没有任何样式，&lt;span style=&quot;color: aqua&quot;&gt;仅仅&lt;/span&gt;为了分割显示样式。&lt;br&gt;换行标签&lt;br&gt;&lt;p&gt; 这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落 这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落&lt;/p&gt;&lt;P&gt; 这是一个新的段落&lt;/P&gt;&lt;div style=&quot;color: brown;width: 100px;height: 100px&quot;&gt; 这是一个div&lt;/div&gt;&lt;div style=&quot;color: chartreuse;width: 100px;height: 100px&quot;&gt; 这是一个新的div&lt;/div&gt;&lt;hr&gt;&lt;hr&gt;&lt;hr&gt;&lt;b&gt;加粗&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;sup&gt;上标&lt;/sup&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;!--无序列表--&gt;&lt;ul type=&quot;square&quot;&gt; &lt;li&gt;sunck is a good man&lt;/li&gt; &lt;li&gt;sunck is a nice man&lt;/li&gt; &lt;li&gt;sunck is a handsome man&lt;/li&gt;&lt;/ul&gt;&lt;!--有序列表--&gt;&lt;ol type=&quot;I&quot;&gt; &lt;li&gt;sunck is a good man&lt;/li&gt; &lt;li&gt;sunck is a nice man&lt;/li&gt; &lt;li&gt;sunck is a handsome man&lt;/li&gt;&lt;/ol&gt;&lt;!--定义列表--&gt;&lt;dl&gt; &lt;dt&gt;学院1&lt;/dt&gt; &lt;dd&gt;电子信息工程1&lt;/dd&gt; &lt;dd&gt;电子信息工程11&lt;/dd&gt; &lt;dt&gt;学院2&lt;/dt&gt; &lt;dd&gt;电子信息工程2&lt;/dd&gt;&lt;/dl&gt;&lt;!--表格--&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;第1行第一列&lt;/td&gt; &lt;td&gt;第1行第二列&lt;/td&gt; &lt;!--&lt;td&gt;第1行第三列&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第2行第一列&lt;/td&gt; &lt;td&gt;第2行第二列&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;第2行第三列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第3行第一列&lt;/td&gt; &lt;td&gt;第3行第二列&lt;/td&gt; &lt;!--&lt;td&gt;第3行第三列&lt;/td&gt;--&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div id=&quot;div1&quot; class=&quot;div1&quot;&gt; 这是一个块标签&lt;/div&gt;&lt;div id=&quot;div2&quot; class=&quot;div2&quot;&gt; 这是一个块&lt;/div&gt;&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;img src=&quot;a.jpg&quot;&gt;&lt;form action=&quot;&quot; method=&quot;get&quot;&gt; First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;br&gt; Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 初始爬虫什么是爬虫网络爬虫就行一只虫子，在互联网上爬啊爬，将获取的信息收集起来。 百度百科的定义为： 网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 爬虫的作用现如今大数据时代已经到来，网络爬虫技术成为这个时代不可或缺的一部分，企业需要数据来分析用户行为，来分析自己产品的不足之处，来分析竞争对手的信息等等，但是这些的首要条件就是数据的采集。 爬虫协议什么是爬虫协议？ 爬虫协议就是你想用爬虫爬我的网站，那么你得听我的，哪些你能爬，哪些你不能爬。 怎么查看一个网站的爬虫协议呢，就在这个网站的域名后面加上robots.txt 比如说下面有：jd、百度、淘宝的爬虫协议 jd：https://www.jd.com/robots.txt 淘宝的：https://www.taobao.com/robots.txt 百度的：https://www.baidu.com/robots.txt 如果你要爬的网站域名加上robots.txt是404，那你就可以随心所欲的爬了。 不过就算爬虫协议里面写了，你也可以不遵守，但是也得注意一下，有的公司发现的话，会起诉的。比如说前几年著名的百度控诉360爬虫违反爬虫协议，索赔1亿元。 爬虫协议里面有这么几个字段： User-agent：* 这个字段的意思是允许哪个引擎的爬虫获取数据 * 代表所有类型的爬虫都可以 Disallow:/admin/ 这个字段代表爬虫不允许爬哪个路径下面的数据，如果是/的话，就代表所有的路径下面的数据都不能爬。 Allow: /cgi-bin/ 这里定义是允许爬寻cgi-bin目录下面的目录 Sitemap: 网站地图 告诉爬虫这个页面是网站地图反爬虫防止有人不遵守爬虫协议恶意爬取网站信息，于是，很多网站开始反网络爬虫,想方设法保护自己的内容。他们根据ip访问频率，浏览网页速度，账户登录，输入验证码，flash封装，ajax混淆，js加密，图片，css混淆等五花八门的技术，来对反网络爬虫。防的一方不惜工本，迫使抓的一方在考虑成本效益后放弃抓的一方不惜工本，防的一方在考虑用户流失后放弃 #请求与响应 HTTP和HTTPS HTTP(HyperText Transfer Protocol，超文本传输协议)：是一种发布和接收HTML页面的方法 HTTPS(HyperText Transfer Protocol over Secure Socket Layer)简单讲是HTTP的安全版，在HTTP下加入SSL层。SSL(Secure Socket Layer安全套接层)主要用于web的安全传输协议，在传输层对网络连接进行加密，保障在Internet上数据传输的安全。 HTTP的端口号为80 HTTPS的端口号为443 http请求过程打开一个网站的时候，过程是这样的客户端（浏览器）发送请求到服务端（你打开的网站所在的服务器），服务端接收到请求，处理，返回数据给客户端（浏览器），然后咱们在浏览器里面看到了数据。 明白了这个过程之后呢，咱们再来说http请求里面都包含了什么东西。 请求方式主要有：GET/POST两种类型常用，另外还有HEAD/PUT/DELETE/OPTIONSGET和POST的区别就是：请求的数据GET是在url中，POST则是存放在请求体里面。 GET:一般向服务器获取数据用get请求，get请求的数据都是放在url中的，实质上和post请求没有太大的区别，当然也可以用来向服务器发送数据。 POST:一般向服务器发送数据用post请求，post请求的数据放在请求体里。 HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 PUT：向指定资源位置上传其最新内容。 OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 DELETE：请求服务器删除Request-URI所标识的资源。 请求urlURL，即统一资源定位符，也就是我们说的网址，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 URL的格式由三个部分组成：第一部分是协议(或称为服务方式)。 http/https第二部分是存有该资源的主机IP地址(有时也包括端口号)。 www.nnzhp.cn/192.168.1.1:8888第三部分是主机资源的具体地址，如目录和文件名等。 /index 爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据。 请求头一个请求由两部分组成， 请求头和请求体。 包含请求时的头部信息，如User-Agent,Host,Cookies等信息，user-agent就是你请求用的是什么浏览器，host就是服务端的地址，还有很多信息，服务端是如何分辨你是用的什么浏览器，你的ip地址就是从请求头里面获取到的。下面就是在请求我博客的时候，发送的头信息。 请求体请求体就是发送数据的时候，数据放在请求体里面。get请求是没有请求体的，从上面的截图也能看到，下面是没有这个请求体的。post请求才有请求体。下面的截图可以看到登陆的这个请求是一个post请求，登陆的账号密码就是放在请求体里面的。 http响应 发送了请求，服务端要返回数据。这个就是响应，请求是你发出去的，响应是服务端返回给你的。 响应包含了2个部分，一个是响应头，一个是响应体。响应头里面包含了响应的状态码，返回数据的类型，类型的长度，服务器信息，Cookie信息等等。 响应体里面就是具体返回的数据了。 响应状态码有很多响应状态，不同的状态码代表不同的状态，常见的状态码如：200代表成功，301跳转，404找不到页面，502服务端错误 1xx消息——请求已被服务器接收，继续处理 2xx成功——请求已成功被服务器接收、理解、并接受 3xx重定向——需要后续操作才能完成这一请求 4xx请求错误——请求含有词法错误或者无法被执行 5xx服务器错误——服务器在处理某个正确请求时发生错误 常见代码： 200 OK 请求成功 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 301 目标暂时性转移 302 目标永久性转移 响应头、响应体 看下图~ 代码示例12345678910111213import requests# 请求头header = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36&quot;&#125;发送get请求response = requests.get(&quot;http://www.xinhuanet.com/politics/2019-06/25/c_1124669748.htm&quot;, headers=header)response.encoding = &quot;utf-8&quot;写入文件with open(&quot;b.html&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(response.text)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫从零开始(五)]]></title>
    <url>%2F2019%2F06%2F25%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[Python 基础Python 输入输出读文件读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符： 1&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;r&apos;) 标示符’r’表示读，这样，我们就成功地打开了一个文件。 如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在： 1234&gt;&gt;&gt; f=open(&apos;/Users/michael/notfound.txt&apos;, &apos;r&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;FileNotFoundError: [Errno 2] No such file or directory: &apos;/Users/michael/notfound.txt&apos; 如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示： 12&gt;&gt;&gt; f.read()&apos;Hello, world!&apos; 最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的： 1&gt;&gt;&gt; f.close() 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现： 123456try: f = open(&apos;/path/to/file&apos;, &apos;r&apos;) print(f.read())finally: if f: f.close() 但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法： 12with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f: print(f.read()) 这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。 调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。 如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便： 123for line in f.readlines(): print(line.strip()) # 把末尾的&apos;\n&apos;删掉file-like Object 像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。 StringIO就是在内存中创建的file-like Object，常用作临时缓冲。 二进制文件前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用&#39;rb&#39;模式打开文件即可： 123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.jpg&apos;, &apos;rb&apos;)&gt;&gt;&gt; f.read()b&apos;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&apos; # 十六进制表示的字节 字符编码要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件： 123&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;)&gt;&gt;&gt; f.read()&apos;测试&apos; 遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略： 1&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;, errors=&apos;ignore&apos;) 写文件写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符&#39;w&#39;或者&#39;wb&#39;表示写文本文件或写二进制文件： 123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)&gt;&gt;&gt; f.close() 你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险： 12with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f: f.write(&apos;Hello, world!&apos;) 要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。 细心的童鞋会发现，以&#39;w&#39;模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入&#39;a&#39;以追加（append）模式写入。 所有模式的定义及含义可以参考Python的官方文档。 读写CSV文件csv文件的读取前期工作：在定义的py文件里边创建一个excel文件，并另存为csv文件，放入三行数据，我这里是姓名+年龄（可以自己随意写） 首先我们要在python环境里导入csv板块 12# -*- coding: utf-8 -*-import csv 然后我们定义一个csv文件的变量csv_file,然后通过open对此文件进行打开，打开模式采用‘r’（read：读模式） 12345with open(&quot;my.csv&quot;, &quot;r&quot;)as f: print(f) csv_file = csv.reader(f) for stu in csv_file: print(stu) 输出结果如下 1234&lt;_csv.reader object at 0x000001D3A1A1B730&gt;[&apos;zhangsan&apos;,&apos;32&apos;][&apos;wangwu&apos;,&apos;34&apos;][&apos;zhaoliu&apos;,&apos;35&apos;] csv文件的写入在开始前我们要定义两组数据，进行下面的写入 12stu1 = [&apos;marry&apos;,26]stu2 = [&apos;bob&apos;,23] 1.写入的第一步同样也是打开文件，因为我们是要写入，所以我们用的模式就是&#39;a&#39;模式，追加内容，至于&quot;newline=&quot;就是说因为我们的csv文件的类型，如果不加这个东西，当我们写入东西的时候，就会出现空行。 1out = open(&apos;Stu_csv.csv&apos;,&apos;a&apos;, newline=&apos;&apos;) 2.下面我们定义一个变量进行写入，将刚才的文件变量传进来，dialect就是定义一下文件的类型，我们定义为excel类型 1csv_write = csv.writer(out,dialect=&apos;excel&apos;) 3.然后进行数据的写入啦，写入的方法是writerow，通过写入模式对象，调用方法进行写入 12csv_write.writerow(stu1)csv_write.writerow(stu2) 4.最后各位可以用你们最熟悉的一句语法进行漂亮的收尾. 1print (&quot;write over&quot;) 具体的代码如下： 12345678910111213import csv#csv 写入stu1 = [&apos;marry&apos;,26]stu2 = [&apos;bob&apos;,23]#打开文件，追加aout = open(&apos;Stu_csv.csv&apos;,&apos;a&apos;, newline=&apos;&apos;)#设定写入模式csv_write = csv.writer(out,dialect=&apos;excel&apos;)#写入具体内容csv_write.writerow(stu1)csv_write.writerow(stu2)print (&quot;write over&quot;) mongoDB安装MongoDB首先到 MongoDB官网 下载安装MongoDB。并且到 MongoChef 官网下载安装可视化管理工具MongoChef studio3t 参考文件 安装PyMongo 驱动用可视化管理工具新建mydb数据库并添加student集合使用以下命令安装pymongo 驱动 1python -m pip install pymongo 也可以指定安装的版本: 1$ python -m pip install pymongo==3.5.1 更新 pymongo 命令： 1$ python -m pip install --upgrade pymongo 测试 PyMongo接下来我们可以创建一个测试文件 demo_test_mongodb.py，代码如下： demo_test_mongodb.py 文件代码： 123#!/usr/bin/python3 import pymongo 执行以上代码文件，如果没有出现错误，表示安装成功。 创建数据库创建一个数据库创建数据库需要使用 MongoClient 对象，并且指定连接的 URL 地址和要创建的数据库名。 如下实例中，我们创建的数据库 runoobdb : 实例 123456#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(&quot;mongodb://localhost:27017/&quot;)mydb = myclient[&quot;runoobdb&quot;] 注意: 在 MongoDB 中，数据库只有在内容插入后才会创建! 就是说，数据库创建后要创建集合(数据表)并插入一个文档(记录)，数据库才会真正创建。 判断数据库是否已存在我们可以读取 MongoDB 中的所有数据库，并判断指定的数据库是否存在： 实例 12345678910#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(&apos;mongodb://localhost:27017/&apos;) dblist = myclient.list_database_names()# dblist = myclient.database_names() if &quot;runoobdb&quot; in dblist: print(&quot;数据库已存在！&quot;) 注意：database_names 在最新版本的 Python 中已废弃，Python3.7+ 之后的版本改为了 list_database_names()。 创建集合MongoDB 中的集合类似 SQL 的表。 创建一个集合MongoDB 使用数据库对象来创建集合，实例如下： 实例 1234567#!/usr/bin/python3import pymongo myclient = pymongo.MongoClient(&quot;mongodb://localhost:27017/&quot;)mydb = myclient[&quot;runoobdb&quot;] mycol = mydb[&quot;sites&quot;] 注意: 在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。 判断集合是否已存在我们可以读取 MongoDB 数据库中的所有集合，并判断指定的集合是否存在： 实例 12345678910#!/usr/bin/python3import pymongomyclient = pymongo.MongoClient(&apos;mongodb://localhost:27017/&apos;)mydb = myclient[&apos;runoobdb&apos;]collist = mydb. list_collection_names()# collist = mydb.collection_names()if &quot;sites&quot; in collist: # 判断 sites 集合是否存在 print(&quot;集合已存在！&quot;) 添加文档操作123456789101112131415161718from pymongo import MongoClient# 连接服务器conn = MongoClient(&quot;localhost&quot;, 27017)# 连接数据库db = conn.mydb# 获取集合collection = db.student# 添加文档# collection.insert(&#123;&quot;name&quot;:&quot;abc&quot;, &quot;age&quot;:19, &quot;gender&quot;:1,&quot;address&quot;:&quot;北京&quot;, &quot;isDelete&quot;:0&#125;)collection.insert_many([&#123;&quot;name&quot;: &quot;abc1&quot;, &quot;age&quot;: 19, &quot;gender&quot;: 1, &quot;address&quot;: &quot;北京&quot;, &quot;isDelete&quot;: 0&#125;, &#123;&quot;name&quot;: &quot;abc2&quot;, &quot;age&quot;: 19, &quot;gender&quot;: 1, &quot;address&quot;: &quot;北京&quot;, &quot;isDelete&quot;: 0&#125;])# 断开conn.close() 查询文档操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import pymongofrom pymongo import MongoClientfrom bson.objectid import ObjectId # 用于ID查询# 连接服务器conn = MongoClient(&quot;localhost&quot;, 27017)# 连接数据库db = conn.mydb# 获取集合collection = db.student# 查询文档# 查询部分文档&apos;&apos;&apos;res = collection.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:18&#125;&#125;)for row in res: print(row) print(type(row))&apos;&apos;&apos;# 查询所有文档&apos;&apos;&apos;res = collection.find()for row in res: print(row) print(type(row))&apos;&apos;&apos;# 统计查询&apos;&apos;&apos;res = collection.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:18&#125;&#125;).count()print(res)&apos;&apos;&apos;# 根据id查询&apos;&apos;&apos;res = collection.find(&#123;&quot;_id&quot;:ObjectId(&quot;5995084b019723fe2a0d8d14&quot;)&#125;)print(res[0])&apos;&apos;&apos;# 排序&apos;&apos;&apos;# res = collection.find().sort(&quot;age&quot;)#升序res = collection.find().sort(&quot;age&quot;, pymongo.DESCENDING)for row in res: print(row)&apos;&apos;&apos;# 分页查询res = collection.find().skip(3).limit(5)for row in res: print(row)# 断开conn.close() 更新文档操作12345678910111213from pymongo import MongoClient# 连接服务器conn = MongoClient(&quot;localhost&quot;, 27017)# 连接数据库db = conn.mydb# 获取集合collection = db.studentcollection.update(&#123;&quot;name&quot;: &quot;lilei&quot;&#125;, &#123;&quot;$set&quot;: &#123;&quot;age&quot;: 25&#125;&#125;)# 断开conn.close() 删除文档操作1234567891011121314from pymongo import MongoClient# 连接服务器conn = MongoClient(&quot;localhost&quot;, 27017)# 连接数据库db = conn.mydb# 获取集合collection = db.studentcollection.remove(&#123;&quot;name&quot;: &quot;lilei&quot;&#125;)# 全部删除collection.remove()# 断开conn.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫从零开始(四)]]></title>
    <url>%2F2019%2F06%2F24%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Python 基础面向对象面向对象（Object Oriented）的英文缩写是OO，它是一种设计思想。我们经常听说的面向对象编程（Object Oriented Programming，即OOP）就是主要针对大型软件设计而提出的，它可以使软件设计更加灵活，并且能更好地进行代码复用。 面向对象中的对象（Object），通常是指客观世界中存在的对象，这个对象具有唯一性，对象之间个不相同，各有各的特点，每一个对象都有自己的运动规律和内部状态；对象和对象之间又是可以相互联系、相互作用的。 对象：是一个抽象概念，英文称为Object，表示任意存在的事物。世间万物皆对象，现实世间中随处可以的一种事物就是对象，对象是事物存在的实体，如一个人。 通常将对象划分为两个部分：静态部分和动态部分。静态部分被称为【属性】，任何对象都具备自身属性，这些属性不仅是客观存在的，而且是不能被忽视的。如人的性别。动态部分指的是对象的行为，即对象执行的动作，如人可以行走。 类和实例面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 代码示例 1234567class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print(&apos;%s: %s&apos; % (self.name, self.score)) 通过class关键字来定义类，类名通常要大写，后面的括号里面表示该类继承于哪个类，所有类最终继承于object类，这类似于Java python允许对实例变量绑定任何数据，因此同一个类的不同实例拥有的变量名称可能会不同 特殊的__init__方法可以把必须绑定给类实例的属性填写进去，它的第一个参数永远是self，表示创建的实例本身，在创建实例的时候，必须传入与init方法匹配的参数，self除外 实际上，Python中类中定义的函数的第一个参数都必须是self，调用时不用传递该参数对Student类使用实例代码： 12345678chen = Student(&apos;chen&apos;, 13)bart = Student(&apos;bart&apos;, 81)chen.print_score()bart.print_score()chen.score = 100bart.name = &apos;kobe&apos;chen.print_score()bart.print_score() 输出结果 1234chen: 13bart: 81chen: 100kobe: 81 访问限制 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问:1234567891011121314class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print(&apos;%s: %s&apos; % (self.__name, self.__score))&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)&gt;&gt;&gt; bart.__nameTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Student&apos; object has no attribute &apos;__name&apos; 这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。 但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法： 12345678class Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score 如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法： 12345class Student(object): ... def set_score(self, score): self.__score = score 你也许会问，原先那种直接通过bart.score = 99也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数： 12345678class Student(object): ... def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError(&apos;bad score&apos;) 需要注意的是，在Python中，变量名类似xxx的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用name、score这样的变量名。以一个下划线开头的变量_name外部可以访问，但是最好把它视为私有变量，不要随便访问python解释器对外把__name改成了_Student__name，因此可以通过_Student__name来访问私有的内部属性(强烈建议不要采用这种方式)： 12&gt;&gt;&gt; bart._Student__name&apos;Bart Simpson&apos; 我们在前面发现无法输出bart.__name，会报错Student类不含有此成员，但是bart.__name = &#39;New Name&#39;语 句是不会报错的，随后再输出bart.__name也不会再报错了： 123456&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)&gt;&gt;&gt; bart.get_name()&apos;Bart Simpson&apos;&gt;&gt;&gt; bart.__name = &apos;New Name&apos; # 设置__name变量！&gt;&gt;&gt; bart.__name&apos;New Name&apos; 这是一种错误的写法，这样设置的__name变量并不是类内部的__name变量，相当于给bart新增了一个变量 继承和多态在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。 比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印： 123class Animal(object): def run(self): print(&apos;Animal is running...&apos;) 当我们需要编写Dog和Cat类时，就可以直接从Animal类继承： 1234class Dog(Animal): passclass Cat(Animal): pass 对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。 继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法： 12345dog = Dog()dog.run()cat = Cat()cat.run() 运行结果如下： 12Animal is running...Animal is running... 当然，也可以对子类增加一些方法，比如Dog类： 1234567class Dog(Animal): def run(self): print(&apos;Dog is running...&apos;) def eat(self): print(&apos;Eating meat...&apos;) 继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running...，符合逻辑的做法是分别显示Dog is running...和Cat is running...，因此，对Dog和Cat类改进如下： 123456789class Dog(Animal): def run(self): print(&apos;Dog is running...&apos;)class Cat(Animal): def run(self): print(&apos;Cat is running...&apos;) 再次运行，结果如下： 12Dog is running...Cat is running... 当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。 要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样： 123a = list() # a是list类型b = Animal() # b是Animal类型c = Dog() # c是Dog类型 判断一个变量是否是某个类型可以用isinstance()判断： 123456&gt;&gt;&gt; isinstance(a, list)True&gt;&gt;&gt; isinstance(b, Animal)True&gt;&gt;&gt; isinstance(c, Dog)True 看来a、b、c确实对应着list、Animal、Dog这3种类型。 但是等等，试试： 12&gt;&gt;&gt; isinstance(c, Animal)True 看来c不仅仅是Dog，c还是Animal！ 不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种！ 所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行： 123&gt;&gt;&gt; b = Animal()&gt;&gt;&gt; isinstance(b, Dog)False Dog可以看成Animal，但Animal不可以看成Dog。 要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量： 123def run_twice(animal): animal.run() animal.run() 当我们传入Animal的实例时，run_twice()就打印出： 123&gt;&gt;&gt; run_twice(Animal())Animal is running...Animal is running... 当我们传入Dog的实例时，run_twice()就打印出： 123&gt;&gt;&gt; run_twice(Dog())Dog is running...Dog is running... 当我们传入Cat的实例时，run_twice()就打印出： 123&gt;&gt;&gt; run_twice(Cat())Cat is running...Cat is running... 看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生： 123class Tortoise(Animal): def run(self): print(&apos;Tortoise is running slowly...&apos;) 当我们调用run_twice()时，传入Tortoise的实例： 123&gt;&gt;&gt; run_twice(Tortoise())Tortoise is running slowly...Tortoise is running slowly... 你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思： 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则： 对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树： 1234567891011121314151617 ┌───────────────┐ │ object │ └───────────────┘ │ ┌────────────┴────────────┐ │ │ ▼ ▼ ┌─────────────┐ ┌─────────────┐ │ Animal │ │ Plant │ └─────────────┘ └─────────────┘ │ │ ┌─────┴──────┐ ┌─────┴──────┐ │ │ │ │ ▼ ▼ ▼ ▼┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐│ Dog │ │ Cat │ │ Tree │ │ Flower │└─────────┘ └─────────┘ └─────────┘ └─────────┘ 获取对象信息使用type()来判断对象类型，它返回对应的Class类型。基本类型可以使用type()来判断： 12345678&gt;&gt;&gt; type(123)&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; type(2.0)&lt;class &apos;float&apos;&gt;&gt;&gt;&gt; type([&quot;sd&quot;,&apos;s&apos;,12])&lt;class &apos;list&apos;&gt;&gt;&gt;&gt; type(None)&lt;class &apos;NoneType&apos;&gt; 函数和类也可以使用type()来判断： 1234567891011&gt;&gt;&gt; class Person:... pass... &gt;&gt;&gt; def test():... pass... &gt;&gt;&gt; p = Person()&gt;&gt;&gt; type(p)&lt;class &apos;__main__.Person&apos;&gt;&gt;&gt;&gt; type(test)&lt;class &apos;function&apos;&gt; 利用type来作为if的判断条件，当类型不是int,str等基本类型时，需要使用types模块中定义的常量： 123456789101112&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():... pass...&gt;&gt;&gt; type(fn)==types.FunctionTypeTrue&gt;&gt;&gt; type(abs)==types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x: x)==types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorTypeTrue 使用isinstance()来判断对象是否是某种类型isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上 能用type()判断的基本类型也可以用isinstance()判断: 123456&gt;&gt;&gt; isinstance(&apos;a&apos;, str)True&gt;&gt;&gt; isinstance(123, int)True&gt;&gt;&gt; isinstance(b&apos;a&apos;, bytes)True isinstance不仅可以判断是否是某种类型，还可以判断是否是某些类型的一种： 1234&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True 使用dir()来获得一个对象的所有属性和方法获取str的所有属性和方法： 12&gt;&gt;&gt; dir(&apos;ABC&apos;)[&apos;__add__&apos;, &apos;__class__&apos;,..., &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;,..., &apos;zfill&apos;] 利用getattr()、setattr()以及hasattr()，我们可以直接操作一个对象,不过这几个函数是在不知道对象信息的时候使用的，在了解对象信息时没有必要使用: 123456789101112131415161718192021&gt;&gt;&gt; class MyObject(object):... def __init__(self):... self.x = 9... def power(self):... return self.x * self.x...&gt;&gt;&gt; obj = MyObject()&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？False&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？True&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;19&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;19 对于getattr()函数，可以在传入的属性参数后面加一个默认的参数，这样在对象不含有这个属性时就会返回默认参数，而不是抛出异常了： 123# 获取属性&apos;z&apos;，如果不存在，返回默认值404&gt;&gt;&gt; getattr(obj, &apos;z&apos;, 404) 404 getattr()函数还可以用于获取方法，把获取的方法赋值给一个变量，那个变量就指向这个方法，调用那个变量就相当于调用了这个方法： 1234567&gt;&gt;&gt; getattr(obj, &apos;power&apos;) # 获取属性&apos;power&apos;&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, &apos;power&apos;) # 获取属性&apos;power&apos;并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81 实例属性和类属性实例属性我们在之前就已经使用过了，我们也了解到在python中可以给一个类实例绑定任何属性，方法是在类方法中利用self或者直接通过实例来绑定。 要给类绑定一个属性的话，可以在类中直接定义它： 12class Student(object): name = &apos;Student&apos; 也可以把类属性成为类的静态成员变量，这个属性是归类所有的，所有实例可以共享它。需要注意的是，虽然name属性归类Student所有，但是类的所有实例都可以访问到，并且实例属性的优先级比类属性高，所以如果实例绑定了一个与类属性同名的实例属性时，优先调用的是实例属性： 12345678910111213141516&gt;&gt;&gt; class Student(object):... name = &apos;Student&apos;...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student 异常处理异常处理捕捉异常可以使用try/except语句。 try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。 如果你不想在异常发生时结束你的程序，只需在try里捕获它。 语法： 以下为简单的try....except...else的语法： 12345678try:&lt;语句&gt; #运行别的代码except &lt;名字&gt;：&lt;语句&gt; #如果在try部份引发了&apos;name&apos;异常except &lt;名字&gt;，&lt;数据&gt;:&lt;语句&gt; #如果引发了&apos;name&apos;异常，获得附加的数据else:&lt;语句&gt; #如果没有异常发生 try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。 如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。 如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印缺省的出错信息）。 如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。 实例 下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，且并未发生异常： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(&quot;testfile&quot;, &quot;w&quot;) fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)except IOError: print &quot;Error: 没有找到文件或读取文件失败&quot;else: print &quot;内容写入文件成功&quot; fh.close() 以上程序输出结果： 1234$ python test.py 内容写入文件成功$ cat testfile # 查看写入的内容这是一个测试文件，用于测试异常!! 实例 下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，但文件没有写入权限，发生了异常： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(&quot;testfile&quot;, &quot;w&quot;) fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)except IOError: print &quot;Error: 没有找到文件或读取文件失败&quot;else: print &quot;内容写入文件成功&quot; fh.close() 在执行代码前为了测试方便，我们可以先去掉 testfile 文件的写权限，命令如下： 1chmod -w testfile 再执行以上代码： 12$ python test.py Error: 没有找到文件或读取文件失败 使用except而不带任何异常类型你可以不带任何异常类型使用except，如下实例： 12345678try: 正常的操作 ......................except: 发生异常，执行这块代码 ......................else: 如果没有异常执行这块代码 以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。 使用except而带多种异常类型你也可以使用相同的except语句来处理多个异常信息，如下所示： 12345678try: 正常的操作 ......................except(Exception1[, Exception2[,...ExceptionN]]]): 发生以上多个异常中的一个，执行这块代码 ......................else: 如果没有异常执行这块代码 try-finally 语句try-finally 语句无论是否发生异常都将执行最后的代码。 12345try:&lt;语句&gt;finally:&lt;语句&gt; #退出try时总会执行raise 实例 12345678#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(&quot;testfile&quot;, &quot;w&quot;) fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)finally: print &quot;Error: 没有找到文件或读取文件失败&quot; 如果打开的文件没有可写权限，输出如下所示： 12$ python test.py Error: 没有找到文件或读取文件失败 同样的例子也可以写成如下方式： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(&quot;testfile&quot;, &quot;w&quot;) try: fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;) finally: print &quot;关闭文件&quot; fh.close()except IOError: print &quot;Error: 没有找到文件或读取文件失败&quot; 当在try块中抛出一个异常，立即执行finally块代码。 finally块中的所有语句执行后，异常被再次触发，并执行except块代码。 参数的内容不同于异常。 异常的参数一个异常可以带上参数，可作为输出的异常信息参数。 你可以通过except语句来捕获异常的参数，如下所示： 12345try: 正常的操作 ......................except ExceptionType, Argument: 你可以在这输出 Argument 的值... 变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。 元组通常包含错误字符串，错误数字，错误位置。 实例以下为单个异常的实例： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*-# 定义函数def temp_convert(var): try: return int(var) except ValueError, Argument: print &quot;参数没有包含数字\n&quot;, Argument# 调用函数temp_convert(&quot;xyz&quot;); 以上程序执行结果如下： 123$ python test.py 参数没有包含数字invalid literal for int() with base 10: &apos;xyz&apos; 触发异常我们可以使用raise语句自己触发异常 raise语法格式如下： 1raise [Exception [, args [, traceback]]] 语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。 最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。 实例一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。 定义一个异常非常简单，如下所示： 1234def functionName( level ): if level &lt; 1: raise Exception(&quot;Invalid level!&quot;, level) # 触发异常后，后面的代码就不会再执行 注意：为了能够捕获异常，”except“语句必须有用相同的异常来抛出类对象或者字符串。 例如我们捕获以上异常，”except“语句如下所示： 123456try: 正常逻辑except Exception,err: 触发自定义异常 else: 其余代码 实例 1234567891011121314#!/usr/bin/python# -*- coding: UTF-8 -*-# 定义函数def mye( level ): if level &lt; 1: raise Exception,&quot;Invalid level!&quot; # 触发异常后，后面的代码就不会再执行try: mye(0) # 触发异常except Exception,err: print 1,errelse: print 2 执行以上代码，输出结果为： 12$ python test.py 1 Invalid level! 用户自定义异常通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。 以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。 在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。 123class Networkerror(RuntimeError): def __init__(self, arg): self.args = arg 在你定义以上类后，你可以触发该异常，如下所示： 1234try: raise Networkerror(&quot;Bad hostname&quot;)except Networkerror,e: print e.args]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫从零开始(三)]]></title>
    <url>%2F2019%2F06%2F23%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Python 基础函数定义函数在Python中定义函数需要使用def语句，接着是函数名、左括号、参数、右括号、冒号：，在缩进块中编写函数体，返回值使用return语句返回。例子：定义my_fun 1234567def my_fun(): print(&quot;Hello World!&quot;)my_fun()#结果 输出Hello World! 函数调用定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。 这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。 如下实例调用了 printme() 函数： 123456789# 定义函数def printme( str ): # 打印任何传入的字符串 print (str) return # 调用函数printme(&quot;我要调用用户自定义函数!&quot;)printme(&quot;再次调用同一函数&quot;) 以上实例输出结果： 12我要调用用户自定义函数!再次调用同一函数 参数传递在 python 中，类型属于对象，变量是没有类型的： 12a=[1,2,3]a=&quot;Runoob&quot; 以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 python 传不可变对象实例123456def ChangeInt( a ): a = 10 b = 2ChangeInt(b)print( b ) # 结果是 2 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 传递可变对象实例可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如： 1234567891011# 可写函数说明def changeme( mylist ): &quot;修改传入的列表&quot; mylist.append([1,2,3,4]) print (&quot;函数内取值: &quot;, mylist) return # 调用changeme函数mylist = [10,20,30]changeme( mylist )print (&quot;函数外取值: &quot;, mylist) 传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下： 12函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数以下是调用函数时可使用的正式参数类型： 必需参数 关键字参数 默认参数 不定长参数 必需参数必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 调用 printme() 函数，你必须传入一个参数，不然会出现语法错误： 实例 12345678#可写函数说明def printme( str ): &quot;打印任何传入的字符串&quot; print (str) return # 调用 printme 函数，不加参数会报错printme() 以上实例输出结果： 1234Traceback (most recent call last): File &quot;test.py&quot;, line 10, in &lt;module&gt; printme()TypeError: printme() missing 1 required positional argument: &apos;str&apos; 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 以下实例在函数 printme() 调用时使用参数名： 实例 12345678#可写函数说明def printme( str ): &quot;打印任何传入的字符串&quot; print (str) return #调用printme函数printme( str = &quot;elichen&quot;) 以上实例输出结果： 1elichen 以下实例中演示了函数参数的使用不需要使用指定顺序： 123456789#可写函数说明def printinfo( name, age ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return #调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; ) 以上实例输出结果： 12名字: runoob年龄: 50 默认参数调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值： 实例 1234567891011#可写函数说明def printinfo( name, age = 35 ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return #调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; )print (&quot;------------------------&quot;)printinfo( name=&quot;runoob&quot; ) 以上实例输出结果： 12345名字: runoob年龄: 50------------------------名字: runoob年龄: 35 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下： 1234def functionname([formal_args,] *var_args_tuple ): &quot;函数_文档字符串&quot; function_suite return [expression] 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 实例 123456789# 可写函数说明def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vartuple) # 调用printinfo 函数printinfo( 70, 60, 50 ) 以上实例输出结果： 123输出: 70(60, 50) 如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例： 123456789101112# 可写函数说明def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) for var in vartuple: print (var) return # 调用printinfo 函数printinfo( 10 )printinfo( 70, 60, 50 ) 以上实例输出结果： 123456输出:10输出:706050 还有一种就是参数带两个星号 **基本语法如下： 1234def functionname([formal_args,] **var_args_dict ): &quot;函数_文档字符串&quot; function_suite return [expression] 加了两个星号 ** 的参数会以字典的形式导入。 123456789# 可写函数说明def printinfo( arg1, **vardict ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vardict) # 调用printinfo 函数printinfo(1, a=2,b=3) 以上实例输出结果： 123输出: 1&#123;&apos;a&apos;: 2, &apos;b&apos;: 3&#125; 声明函数时，参数中星号 * 可以单独出现，例如: 12def f(a,b,*,c): return a+b+c 如果单独出现星号 * 后的参数必须用关键字传入。 12345678910&gt;&gt;&gt; def f(a,b,*,c):... return a+b+c... &gt;&gt;&gt; f(1,2,3) # 报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: f() takes 2 positional arguments but 3 were given&gt;&gt;&gt; f(1,2,c=3) # 正常6&gt;&gt;&gt; 模块Python3模块在前面的几个章节中我们脚本上是用 python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。 为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。 模块是一个包含所有你定义的函数和变量的文件，其后缀名是 .py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。 下面是一个使用 python 标准库中模块的例子。 1234567import sys print(&apos;命令行参数如下:&apos;)for i in sys.argv: print(i) print(&apos;\n\nPython 路径为：&apos;, sys.path, &apos;\n&apos;) 执行结果如下所示： 12345678$ python using_sys.py 参数1 参数2命令行参数如下:using_sys.py参数1参数2Python 路径为： [&apos;/root&apos;, &apos;/usr/lib/python3.4&apos;, &apos;/usr/lib/python3.4/plat-x86_64-linux-gnu&apos;, &apos;/usr/lib/python3.4/lib-dynload&apos;, &apos;/usr/local/lib/python3.4/dist-packages&apos;, &apos;/usr/lib/python3/dist-packages&apos;] 1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。 2、sys.argv 是一个包含命令行参数的列表。 3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。导入模块语句想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：1import module1[, module2[,... moduleN] Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下： 1from modname import name1[, name2[, ... nameN]] 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： 1from modname import *]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫从零开始(二)]]></title>
    <url>%2F2019%2F06%2F22%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Python 基础基本数据类型Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。 123a = 100 #整型变量b = 100.1 #浮点型变量c = &quot;elichen&quot; #字符型 Python允许多个变量同时赋值例如 1a = b = c = 1 你也可以为多个对象指定多个变量 1a, b, c = 1, 2, &quot;elichen&quot; 标准数据类型Python3 中有六个标准数据类型： Number （数字） String （字符串） List （列表） Tuple （元组） Set （集合） Dictionary（字典） Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 1、Number（数字）Python3 支持 int、float、bool、complex（复数） 关于布尔类型： Python3中，把True和False定义成关键字，他们的值是1和0，它们可以和数字相加。 在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 像大多数语言一样，数值类型的赋值和计算都是很直观的。 内置的 type() 函数可以用来查询变量所指的对象类型。 此外还可以用 isinstance 来判断： 123a = 1isinstance(a, int)# 结果为True isinstance 和 type 的区别在于： type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 当你指定一个值时，Number 对象就会被创建： 12var1 = 1var2 = 10 你也可以使用del语句删除一些对象引用。 del语句的语法是： 1del var1[,var2[,var3[....,varN]]] 您可以通过使用del语句删除单个或多个对象。例如: 12del vardel var_a, var_b 数值运算 1234567891011121314&gt;&gt;&gt;5 + 4 # 加法9&gt;&gt;&gt; 4.3 - 2 # 减法2.3&gt;&gt;&gt; 3 * 7 # 乘法21&gt;&gt;&gt; 2 / 4 # 除法，得到一个浮点数0.5&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数0&gt;&gt;&gt; 17 % 3 # 取余 2&gt;&gt;&gt; 2 ** 5 # 乘方32 2、String（字符串）Python中的字符串用单引号(‘)或双引号(“)括起来，同时使用反斜杠()转义特殊字符。 字符串的截取的语法格式如下： 变量[头下标:尾下标] 加号 + 是字符串的连接符， 星号 * 表示复制当前字符串，紧跟的数字为复制的次数。实例如下： 123456789str = &apos;Elichen&apos; print (str) # 输出字符串print (str[0:-1]) # 输出第一个到倒数第二个的所有字符print (str[0]) # 输出字符串第一个字符print (str[2:5]) # 输出从第三个开始到第五个的字符print (str[2:]) # 输出从第三个开始的后的所有字符print (str * 2) # 输出字符串两次print (str + &quot;TEST&quot;) # 连接字符串 执行以上程序会输出如下结果： 1234567ElichenElicheEichichenElichenElichenElichenTEST Python 使用反斜杠()转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串： 123456&gt;&gt;&gt; print(&apos;Ru\noob&apos;)Ruoob&gt;&gt;&gt; print(r&apos;Ru\noob&apos;)Ru\noob&gt;&gt;&gt; 3、List（列表）List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 列表截取的语法格式如下： 变量[头下标:尾下标] 加号 + 是列表连接运算符，星号 * 是重复操作。如下实例： 123456789list = [&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2]tinylist = [123, &apos;elichen&apos;]print(list) # 输出完整列表print(list[0]) # 输出列表第一个元素print(list[1:3]) # 从第二个开始输出到第三个元素print(list[2:]) # 输出从第三个元素开始的所有元素print(tinylist * 2) # 输出两次列表print(list + tinylist) # 连接列表 以上实例输出结果： 123456[&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2]abcd[786, 2.23][2.23, &apos;elichen&apos;, 70.2][123, &apos;elichen&apos;, 123, &apos;elichen&apos;][&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2, 123, &apos;elichen&apos;] 与Python字符串不一样的是，列表中的元素是可以改变的： 12345678&gt;&gt;&gt;a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; a[0] = 9&gt;&gt;&gt; a[2:5] = [13, 14, 15]&gt;&gt;&gt; a[9, 2, 13, 14, 15, 6]&gt;&gt;&gt; a[2:5] = [] # 将对应的元素值设置为 [] &gt;&gt;&gt; a[9, 2, 6] List写在方括号之间，元素用逗号隔开。 和字符串一样，list可以被索引和切片。 List可以使用+操作符进行拼接。 List中的元素是可以改变的。 Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： 123list1 = [&apos;e&apos;, &apos;l&apos;, &apos;i&apos;, &apos;c&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;]print(list1[1:4:2])# 结果为 [&apos;l&apos;, &apos;c&apos;] 4、Tuple（元组）语法：(,,,)。使用()标识，元素之间用逗号分隔。 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。 元组中的元素类型也可以不相同； 123456789tuple = (&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2)tinytuple = (123, &apos;elichen&apos;)print(tuple) # 输出完整元组print(tuple[0]) # 输出元组的第一个元素print(tuple[1:3]) # 输出从第二个元素开始到第三个元素print(tuple[2:]) # 输出从第三个元素开始的所有元素print(tinytuple * 2) # 输出两次元组print(tuple + tinytuple) # 连接元组 以上实例输出结果： 123456(&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2)abcd(786, 2.23)(2.23, &apos;elichen&apos;, 70.2)(123, &apos;elichen&apos;, 123, &apos;elichen&apos;)(&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2, 123, &apos;elichen&apos;) 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则： 12tup1 = () # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号 string、list 和 tuple 都属于 sequence（序列）。 注意： 1、与字符串一样，元组的元素不能修改。 2、元组也可以被索引和切片，方法一样。 3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。 4、元组也可以使用+操作符进行拼接。 5、Set（集合）集合（set）是一个无序不重复元素的序列。创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 创建格式： 123parame = &#123;value01,value02,...&#125;或者set(value) 实例 12345678910111213141516171819student = &#123;&apos;Tom&apos;, &apos;Jim&apos;, &apos;Mary&apos;, &apos;Tom&apos;, &apos;Jack&apos;, &apos;Rose&apos;&#125; print(student) # 输出集合，重复的元素被自动去掉 # 成员测试if &apos;Rose&apos; in student : print(&apos;Rose 在集合中&apos;)else : print(&apos;Rose 不在集合中&apos;)# set可以进行集合运算a = set(&apos;abracadabra&apos;)b = set(&apos;alacazam&apos;) print(a)print(a - b) # a 和 b 的差集print(a | b) # a 和 b 的并集print(a &amp; b) # a 和 b 的交集print(a ^ b) # a 和 b 中不同时存在的元素 以上实例输出结果： 1234567&#123;&apos;Mary&apos;, &apos;Jim&apos;, &apos;Rose&apos;, &apos;Jack&apos;, &apos;Tom&apos;&#125;Rose 在集合中&#123;&apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;r&apos;, &apos;d&apos;&#125;&#123;&apos;b&apos;, &apos;d&apos;, &apos;r&apos;&#125;&#123;&apos;l&apos;, &apos;r&apos;, &apos;a&apos;, &apos;c&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;&#125;&#123;&apos;a&apos;, &apos;c&apos;&#125;&#123;&apos;l&apos;, &apos;r&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;&#125; 6、Dictionary（字典）字典是一种映射类型，字典用{ }标识，它是一个无序的键(key) : 值(value)对集合。 字典（dictionary）是Python中另一个非常有用的内置数据类型，键(key)必须使用不可变类型，键(key)必须是唯一的。 123456789101112dict = &#123;&#125;dict[&apos;one&apos;] = &quot;1&quot;dict[2] = &quot;2&quot; tinydict = &#123;&apos;name&apos;: &apos;elichen&apos;,&apos;code&apos;:1, &apos;site&apos;: &apos;www.elichen.club&apos;&#125; print (dict[&apos;one&apos;]) # 输出键为 &apos;one&apos; 的值print (dict[2]) # 输出键为 2 的值print (tinydict) # 输出完整的字典print (tinydict.keys()) # 输出所有键print (tinydict.values()) # 输出所有值 以上实例输出结果： 1234512&#123;&apos;name&apos;: &apos;elichen&apos;, &apos;code&apos;: 1, &apos;site&apos;: &apos;www.elichen.club&apos;&#125;dict_keys([&apos;name&apos;, &apos;code&apos;, &apos;site&apos;])dict_values([&apos;elichen&apos;, 1, &apos;www.elichen.club&apos;]) 注意： 1、字典是一种映射类型，它的元素是键值对。 2、字典的关键字必须为不可变类型，且不能重复。 3、创建空字典使用 { }。 Python数据类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。 函数 描述 int(x [,base]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫从零开始(一)]]></title>
    <url>%2F2019%2F06%2F21%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[（一） Python环境搭建第一步:Python安装包下载首先从 Python官网 下载Python安装程序，注意32位和64位的区别，如果你的电脑是32位的请选择32位的安装包，如果你的电脑是64位的请选择64位的安装包。 第二步:安装双击下载好的Python安装包。 勾选添加Python到环境变量，选择默认安装或者自定义安装，如果忘记打勾，则需要手工加到环境变量中；在这里我选择的是自定义安装，点击“自定义安装”进行下一步操作； 进入到下一步后，选择需要安装的组件，然后点击下一步: 在这里可以自定义路径选择安装： 点击下一步后，就开始真正安装了，安装完成后点击关闭即可。 第三步: 测试python安装好之后，我们要检测一下是否安装成功，用系统管理员打开命令行工具cmd，输入“python”,然后敲回车，如果出现如下界面，则表示我们安装成功了； 如果不显示版本号，提示‘python’ 不是内部或外部命令，也不是可运行的程序或批处理文件，则需要手动将python.exe所在的目录添加到环境变量PATH中。 （二）pycharm的安装与配置第一步:下载pycharm点击 pycharm官网 进入pycharm 官网下载免费的Community版本 第二步:安装pycharm双击下载的安装包,出现如下界面点击next 可以选择安装位置，继续点击next 勾选以下选项，点击next 点击install 第三步:pycharm的入门基础配置安装完成打开pycharm显示如下，因为之前安装过所以会让我当如配置文件，没安装过的选择不导入设置，点击OK。 同意协议点击继续 选择喜欢的主题 选择你要安装的插件继续 打开设置 展开editor 双击Font 设置你喜欢的字体样式和大小 第四步:pycharm的Python解释器的搭建 完成如下操作点击OK。 点击OK完成设置 更新Python解释器 完成后就可以新建工程愉快的写代码了。 第五步:pycharm的建立一个新项目点击create New Project 选择项目路径 选择项目解释器，选择刚刚设置的Python解释器 点击create 项目目录右键点击选择new 选择 Python File 给文件起个名字点击OK 写入代码右键单击编辑区选择Run 输出结果 大功告成! 至此，pycharm已经全部安装完成。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[happybirthday]]></title>
    <url>%2F2019%2F04%2F18%2F%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX18xgh3jZI6iE7ja7dptfRqK9IB1HuMS1m+RyfAW/dxlt+Cg4EaCgII+/6tXCSi3/Uw/u5jplX7bPXSUcBpg8iySzA2DGpsx1L0SfqBkkJuP1Pbzf6sbrEfNRSRGgkG6gS7TqYmKAXRnTMTrSHEKmGkr/a+DyeFY5lAkMhYYglwPULA9OayUJ6QD var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[给🐖的信]]></title>
    <url>%2F2019%2F03%2F30%2F%E4%B8%80%E5%91%A8%E5%B9%B4%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19Ox99+pyLLL7SzbTAvNe4g+vbaFbK9kqOj4swiygGyqdIsAJ+AByn+hZsO8YGj/J9Qr9fGVpEextXVFgewPhomAHyzM/KOxGDRzLQn+vu/dJM91YChQd+BVD6SP9PIk+Xq4vgSGMAN03sBIuRGdJdxU/QYIR6SuC8Gm6aobirE2499jtA3K1Oz var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
  </entry>
</search>
