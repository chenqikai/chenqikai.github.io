<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java集合框架]]></title>
    <url>%2F2019%2F07%2F31%2Fjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Java集合框架集合与框架集合Java中集合就如一个容器(Container)，集合中可以存放各种对象，集合本身也是一个对象。 集合框架那么有了集合的概念，什么是集合框架呢？集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。 接口：即表示集合的抽象数据类型。接口提供了让我们对集合中所表示的内容进行单独操作的可能。 实现：也就是集合框架中接口的具体实现。实际它们就是那些可复用的数据结构。 算法：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。 集合框架结构集合框架总体结构图 从图中可以看出，Java集合框架主要包括两种类型的容器，一种是集合(Collection),存储一个元素集合，另一种是图(Map)，存储键值对映射。Collection接口有三个子类型，List，Set，Quee，接着是一些抽象类，最后是具体的实现类，常用的类有ArrayList，HashSet，LinkedHashSet、HashMap、LinkedHashMap 等等。 除了集合，该框架也定义了几个Map接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。 Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。 常见接口及实现类Collection接口该接口为集合类的顶级父类该类中的方法（来源于API）如下 Set类Set集合与Collection的方法相同，由于Set集合不允许存储相同的元素，所以如果把两个相同元素添加到同一个Set集合，则添加操作失败，新元素不会被加入，add()方法返回false。 代码示例： 12345678910public class Test &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;hello world&quot;); set.add(&quot;hello elichen&quot;); set.add(&quot;hello elichen&quot;);//添加不进去 System.out.println(&quot;集合中元素个数：&quot;+set.size()); System.out.println(&quot;集合中元素为：&quot;+set.toString()); &#125;&#125; 运行结果如下： 12集合中元素个数：2集合中元素为：[hello world, hello elichen] 由于String类中重写了hashCode()和equals()方法，用来比较指向的字符串对象所存储的字符串是否相等。所以这里的第二个”hello elichen”是加不进去的。 HashSet类HashSet是Set集合最常用实现类。HashSet是按照hash算法来存储元素的，因此具有很好的存取和查找性能。 HashSet具有如下特点： 不能保证元素的顺序。 HashSet不是线程同步的，如果多线程操作HashSet集合，则应通过代码来保证其同步。 集合元素值可以是null。 HashSet存储原理如下： 当向HashSet集合存储一个元素时，HashSet会调用该对象的hashCode()方法得到其hashCode值，然后根据hashCode值决定该对象的存储位置。HashSet集合判断两个元素相等的标准是(1)两个对象通过equals()方法比较返回true；(2)两个对象的hashCode()方法返回值相等。因此，如果(1)和(2)有一个不满足条件，则认为这两个对象不相等，可以添加成功。如果两个对象的hashCode()方法返回值相等，但是两个对象通过equals()方法比较返回false，HashSet会以链式结构将两个对象保存在同一位置，这将导致性能下降，因此在编码时应避免出现这种情况。 HashSet查找原理如下： 基于HashSet以上的存储原理，在查找元素时，HashSet先计算元素的HashCode值（也就是调用对象的hashCode方法的返回值），然后直接到hashCode值对应的位置去取出元素即可，这就是HashSet速度很快的原因。 重写hashCode()方法的基本原则如下： 在程序运行过程中，同一个对象的hashCode()方法返回值应相同。 当两个对象通过equals()方法比较返回true时，这两个对象的hashCode()方法返回值应该相等。 对象中用作equals()方法比较标准的实例变量，都应该用于计算hashCode值。 LinkedHashSet类LinkedHashSet是HashSet的一个子类，具有HashSet的特性，也是根据元素的hashCode值来决定元素的存储位置。但它使用链表维护元素的次序，元素的顺序与添加顺序一致。由于LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet，但在迭代访问Set里的全部元素时由很好的性能。 TreeSet类TreeSet时SortedSet接口的实现类，TreeSet可以保证元素处于排序状态，它采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方法：自然排序和定制排序，默认采用自然排序。 自然排序 TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素的大小关系，然后将元素按照升序排列，这就是自然排序。如果试图将一个对象添加到TreeSet集合中，则该对象必须实现Comparable接口，否则会抛出异常。当一个对象调用方法与另一个对象比较时，例如obj1.compareTo(obj2)，如果该方法返回0，则两个对象相等；如果返回一个正数，则obj1大于obj2；如果返回一个负数，则obj1小于obj2。 Java常用类中已经实现了Comparable接口的类有以下几个： BigDecimal、BigDecimal以及所有数值型对应的包装类：按照它们对应的数值大小进行比较。 Charchter：按照字符的unicode值进行比较。 Boolean：true对应的包装类实例大于false对应的包装类实例。 String：按照字符串中的字符的unicode值进行比较。 Date、Time：后面的时间、日期比前面的时间、日期大。 对于TreeSet集合而言，它判断两个对象是否相等的标准是：两个对象通过compareTo(Object obj)方法比较是否返回0，如果返回0则相等。 定制排序 想要实现定制排序，需要在创建TreeSet集合对象时，提供一个Comparator对象与该TreeSet集合关联，由Comparator对象负责集合元素的排序逻辑。 综上：自然排序实现的是Comparable接口，定制排序实现的是Comparator接口。 EnumSet类EnumSet是一个专为枚举类设计的集合类，不允许添加null值。EnumSet的集合元素也是有序的，它以枚举值在Enum类内的定义顺序来决定集合元素的顺序。 各Set实现类的性能分析HashSet的性能比TreeSet的性能好（特别是添加，查询元素时），因为TreeSet需要额外的红黑树算法维护元素的次序，如果需要一个保持排序的Set时才用TreeSet，否则应该使用HashSet。 LinkedHashSet是HashSet的子类，由于需要链表维护元素的顺序，所以插入和删除操作比HashSet要慢，但遍历比HashSet快。 EnumSet是所有Set实现类中性能最好的，但它只能 保存同一个枚举类的枚举值作为集合元素。 以上几个Set实现类都是线程不安全的，如果多线程访问，必须手动保证集合的同步性 List类List集合代表一个有序、可重复集合，集合中每个元素都有其对应的顺序索引。List集合默认按照元素的添加顺序设置元素的索引，可以通过索引（类似数组的下标）来访问指定位置的集合元素。 实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 ArrayListArrayList是一个动态数组，也是我们最常用的集合，是List类的典型实现。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。ArrayList擅长于随机访问。同时ArrayList是非同步的。 LinkedListLinkedList是List接口的另一个实现，除了可以根据索引访问集合元素外，LinkedList还实现了Deque接口，可以当作双端队列来使用，也就是说，既可以当作“栈”使用，又可以当作队列使用。 LinkedList的实现机制与ArrayList的实现机制完全不同，ArrayLiat内部以数组的形式保存集合的元素，所以随机访问集合元素有较好的性能；LinkedList内部以链表的形式保存集合中的元素，所以随机访问集合中的元素性能较差，但在插入删除元素时有较好的性能。 Vector与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。 StackStack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 Iterator接口和ListIterator接口Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口如下： boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。 Object next()：返回集合里下一个元素。 void remove()：删除集合里上一次next方法返回的元素。 ListIterator接口继承Iterator接口，提供了专门操作List的方法。ListIterator接口在Iterator接口的基础上增加了以下几个方法： boolean hasPrevious()：判断集合里是否存在上一个元素。如果有，该方法返回 true。 Object previous()：返回集合里上一个元素。 void add(Object o)：在指定位置插入一个元素。 以上两个接口相比较，不难发现，ListIterator增加了向前迭代的功能（Iterator只能向后迭代），ListIterator还可以通过add()方法向List集合中添加元素（Iterator只能删除元素）。 Map类Map接口采用键值对Map&lt;K,V&gt;的存储方式，保存具有映射关系的数据，因此，Map集合里保存两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value，key和value可以是任意引用类型的数据。key值不允许重复，可以为null。如果添加key-value对时Map中已经有重复的key，则新添加的value会覆盖该key原来对应的value。常用实现类有HashMap、LinkedHashMap、TreeMap等。 Map常见方法（来源于API）如下： Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。 HashMap以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 LinkedHashMapLinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。 TreeMapTreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。 自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。 定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。 TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。 如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异常处理]]></title>
    <url>%2F2019%2F07%2F28%2Fjava%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面向对象]]></title>
    <url>%2F2019%2F07%2F26%2Fjava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[java 面向对象面向对象简介“面向对象” (英语：Object Oriented,简称OO)是一种以事物为中心的编程思想。面向对象程序设计（英语：Object-oriented programming，缩写：OOP），是一种程序开发的方法。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。 面向对象是相对于面向过程而言的（C则是一个典型的面向过程的语言），站在面向对象的角度去看问题，你则是对象的动作的指挥者。如果站在面向过程的角度去看问题，你则是动作的执行者。“面向过程”强调的是功能行为，面向过程”是一种以过程为中心的编程思想。“面向过程”他们不支持丰富的“面向对象”特性（比如继承、多态），就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向过程在这一系列工作的执行中，强调的是工作的执行。 java是完全面向对象的语言，那么什么是面向对象呢？ 举个栗子： 你饿了想去吃饭！ 基于面向过程你就是动作的执行者，首先你要出去买菜然后洗菜接着做菜最后感觉真难吃，浪费时间有没吃饱！ 基于面向对象你是动作的执行者，首先找一家餐厅然后想服务员点饭等待服务员上饭，饭上来了然后吃饭，饭好吃又节约时间。面向对象与面向过程对比 1.面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。 2.面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。 面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们我们使用的就是面向对象了。 面向过程： 优点：性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源。 缺点：不易维护、不易复用、不易扩展. 面向对象： 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 . 缺点：性能比面向过程差 面向对象的特征(1)抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。 (2)继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 (3)封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 (4) 多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 面向对象的”六原则一法则” 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。） 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。） 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。） 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基本数据类型]]></title>
    <url>%2F2019%2F07%2F16%2Fjava%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[java基本数据类型整型byte： byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short： short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s = 1000，short r = -20000。 int： int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 默认值是 0 ；例子：int a = 100000, int b = -200000。 long： long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L。 “L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。 浮点型float： float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币；例子：float f1 = 234.5f。 double： double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； 例子：double d1 = 123.4。 ###boolean： boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子： boolean one = true。 字符型char： char类型是一个单一的 16 位 Unicode 字符； 最小值是 \u0000（即为0）； 最大值是 \uffff（即为65,535）； char 数据类型可以储存任何字符；例子：char letter = &#39;A&#39;;。 面试题1 123456789101112131415161718public class Demo_面试题 &#123; public static void main(String[] args) &#123; int a = 1; short b = 2; /* b = b+a; // 编译报错 System.out.println(b); */ b+=a; // 这个不会报错，因为 +=在运算时底层会有一个强制类型转换 System.out.println(b); &#125;&#125; 面试题2 1234567891011121314151617181920public class Demo_面试题2 &#123; public static void main(String[] args) &#123; byte b1 = 1; byte b2 = 2; byte b3 = 1+2; // 在编译就直接计算结果为3 赋给了 b3 System.out.println(b3); //3 /* byte result = b1+b2; // 编译报错 在编译时，因为b1和b2都是变量，因此不能确定b1+b2的值是否超过byte的范围 System.out.println(result); */ //常量优化机制：有一些计算，非常简单，例如常量和常量的计算就非常简单，在编译阶段就可以把这些简单的运算计算完。 &#125;&#125; 交换两个变量的值 123456789101112131415161718192021222324252627public class Demo_练习_交换两个变量的值 &#123; public static void main(String[] args) &#123; int a = 5; int b = 8; System.out.println(&quot;a=&quot;+a); System.out.println(&quot;b=&quot;+b); /* int temp = 0; //空瓶 temp = a; a = b; b =temp; */ // 不允许使用第3个变量，完成交换 a = a+b; // a = 13 b = 5; b = a-b; // b = 8 a = 13 a = a-b; // a = 5 b = 8; System.out.println(&quot;a=&quot;+a); System.out.println(&quot;b=&quot;+b); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java流程控制语句]]></title>
    <url>%2F2019%2F07%2F16%2Fjava%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[java流程控制语句条件语句if语句一个 if 语句包含一个布尔表达式和一条或多条语句。语法 1234if(布尔表达式)&#123; //如果布尔表达式为true将执行的语句&#125; 如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 if 语句块后面的代码。 if…else语句if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。 语法 1234567if…else 的用法如下：if(布尔表达式)&#123; //如果布尔表达式的值为true&#125;else&#123; //如果布尔表达式的值为false&#125; if…else if…else 语句if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。 使用 if，else if，else 语句的时候，需要注意下面几点： if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。 if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。语法if…else 语法格式如下:123456789if(布尔表达式 1)&#123; //如果布尔表达式 1的值为true执行代码&#125;else if(布尔表达式 2)&#123; //如果布尔表达式 2的值为true执行代码&#125;else if(布尔表达式 3)&#123; //如果布尔表达式 3的值为true执行代码&#125;else &#123; //如果以上布尔表达式都不为true执行代码&#125; 嵌套的 if…else 语句使用嵌套的 if…else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。 语法 嵌套的 if…else 语法格式如下： 123456if(布尔表达式 1)&#123; ////如果布尔表达式 1的值为true执行代码 if(布尔表达式 2)&#123; ////如果布尔表达式 2的值为true执行代码 &#125;&#125; 你可以像 if 语句一样嵌套 else if…else。 循环语句while 循环while是最基本的循环，它的结构为： 123while( 布尔表达式 ) &#123; //循环内容&#125; 只要布尔表达式为 true，循环就会一直执行下去。 do…while 循环对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 123do &#123; //代码语句&#125;while(布尔表达式); 注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。 for循环虽然所有循环结构都可以用 while 或者 do…while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。 for循环执行的次数是在执行前就确定的。语法格式如下： 123for(初始化; 布尔表达式; 更新) &#123; //代码语句&#125; 关于 for 循环有以下几点说明： 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。 执行一次循环后，更新循环控制变量。 再次检测布尔表达式。循环执行上面的过程。 Java 增强 for 循环Java5 引入了一种主要用于数组的增强型 for 循环。 Java 增强 for 循环语法格式如下: 1234for(声明语句 : 表达式)&#123; //代码句子&#125; 声明语句 ：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 break 关键字break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。 break 跳出最里层的循环，并且继续执行该循环下面的语句。 语法break 的用法很简单，就是循环结构中的一条语句： 1break; continue 关键字continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。 在 for 循环中，continue 语句使程序立即跳转到更新语句。 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。 语法continue 就是循环体中一条简单的语句： 1continue; 假设修正法 求最大值求a,b,c三个数中的最大值。 /有a,b,c三个数字，求最大值。/ 123456789101112131415public class MaxNumber &#123; public static void main(String[] args) &#123; int a = 3; int b = 10; int c = 7; int m = a;// 假设，为真 if (b &gt; m) &#123;// 修改 m = b; &#125; if (c &gt; m) &#123;// 修改 m = c; &#125; System.out.println(m); &#125;&#125; 结果为 10 判断闰年求某一个年份是不是闰年。 /判断是否是闰年/ 1234567891011121314151617181920212223public class RunYear &#123; public static void main(String[] args) &#123;// int year = 2000;// boolean t = year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0;//可读性太差// System.out.println(t); //假设修正法 int year =2000; boolean t = false;//假设不是闰年 if(year%4==0)&#123; t=true; &#125; if(year%100==0)&#123; t=false; &#125; if(year%400==0)&#123; t=true; &#125; System.out.println(year+&quot;是否闰年：&quot;+t); &#125; &#125; 结果为 2000是否闰年：true]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫从零开始(六)]]></title>
    <url>%2F2019%2F06%2F26%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[认识HTML什么是HTMLHTML 是用来描述网页的一种语言。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 标签HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt; HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 HTML 文档 = 网页 HTML 文档描述网页 HTML 文档包含 HTML 标签和纯文本 HTML 文档也被称为网页Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容：123456789&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子解释 &lt;html&gt; 与 &lt;/html&gt; 之间的文本描述网页 &lt;body&gt; 与 &lt;/body&gt; 之间的文本是可见的页面内容 &lt;h1&gt; 与 &lt;/h1&gt; 之间的文本被显示为标题 &lt;p&gt; 与 &lt;/p&gt; 之间的文本被显示为段落 以下是常用标签及其含义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;style&gt; #div1 &#123; color: brown; &#125; .div2 &#123; color: chartreuse; &#125; div &#123; color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt;span标签没有任何样式，&lt;span style=&quot;color: aqua&quot;&gt;仅仅&lt;/span&gt;为了分割显示样式。&lt;br&gt;换行标签&lt;br&gt;&lt;p&gt; 这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落 这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落这是一个段落&lt;/p&gt;&lt;P&gt; 这是一个新的段落&lt;/P&gt;&lt;div style=&quot;color: brown;width: 100px;height: 100px&quot;&gt; 这是一个div&lt;/div&gt;&lt;div style=&quot;color: chartreuse;width: 100px;height: 100px&quot;&gt; 这是一个新的div&lt;/div&gt;&lt;hr&gt;&lt;hr&gt;&lt;hr&gt;&lt;b&gt;加粗&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;sup&gt;上标&lt;/sup&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;!--无序列表--&gt;&lt;ul type=&quot;square&quot;&gt; &lt;li&gt;sunck is a good man&lt;/li&gt; &lt;li&gt;sunck is a nice man&lt;/li&gt; &lt;li&gt;sunck is a handsome man&lt;/li&gt;&lt;/ul&gt;&lt;!--有序列表--&gt;&lt;ol type=&quot;I&quot;&gt; &lt;li&gt;sunck is a good man&lt;/li&gt; &lt;li&gt;sunck is a nice man&lt;/li&gt; &lt;li&gt;sunck is a handsome man&lt;/li&gt;&lt;/ol&gt;&lt;!--定义列表--&gt;&lt;dl&gt; &lt;dt&gt;学院1&lt;/dt&gt; &lt;dd&gt;电子信息工程1&lt;/dd&gt; &lt;dd&gt;电子信息工程11&lt;/dd&gt; &lt;dt&gt;学院2&lt;/dt&gt; &lt;dd&gt;电子信息工程2&lt;/dd&gt;&lt;/dl&gt;&lt;!--表格--&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;第1行第一列&lt;/td&gt; &lt;td&gt;第1行第二列&lt;/td&gt; &lt;!--&lt;td&gt;第1行第三列&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第2行第一列&lt;/td&gt; &lt;td&gt;第2行第二列&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;第2行第三列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第3行第一列&lt;/td&gt; &lt;td&gt;第3行第二列&lt;/td&gt; &lt;!--&lt;td&gt;第3行第三列&lt;/td&gt;--&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div id=&quot;div1&quot; class=&quot;div1&quot;&gt; 这是一个块标签&lt;/div&gt;&lt;div id=&quot;div2&quot; class=&quot;div2&quot;&gt; 这是一个块&lt;/div&gt;&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;img src=&quot;a.jpg&quot;&gt;&lt;form action=&quot;&quot; method=&quot;get&quot;&gt; First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;br&gt; Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 初始爬虫什么是爬虫网络爬虫就行一只虫子，在互联网上爬啊爬，将获取的信息收集起来。 百度百科的定义为： 网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 爬虫的作用现如今大数据时代已经到来，网络爬虫技术成为这个时代不可或缺的一部分，企业需要数据来分析用户行为，来分析自己产品的不足之处，来分析竞争对手的信息等等，但是这些的首要条件就是数据的采集。 爬虫协议什么是爬虫协议？ 爬虫协议就是你想用爬虫爬我的网站，那么你得听我的，哪些你能爬，哪些你不能爬。 怎么查看一个网站的爬虫协议呢，就在这个网站的域名后面加上robots.txt 比如说下面有：jd、百度、淘宝的爬虫协议 jd：https://www.jd.com/robots.txt 淘宝的：https://www.taobao.com/robots.txt 百度的：https://www.baidu.com/robots.txt 如果你要爬的网站域名加上robots.txt是404，那你就可以随心所欲的爬了。 不过就算爬虫协议里面写了，你也可以不遵守，但是也得注意一下，有的公司发现的话，会起诉的。比如说前几年著名的百度控诉360爬虫违反爬虫协议，索赔1亿元。 爬虫协议里面有这么几个字段： User-agent：* 这个字段的意思是允许哪个引擎的爬虫获取数据 * 代表所有类型的爬虫都可以 Disallow:/admin/ 这个字段代表爬虫不允许爬哪个路径下面的数据，如果是/的话，就代表所有的路径下面的数据都不能爬。 Allow: /cgi-bin/ 这里定义是允许爬寻cgi-bin目录下面的目录 Sitemap: 网站地图 告诉爬虫这个页面是网站地图反爬虫防止有人不遵守爬虫协议恶意爬取网站信息，于是，很多网站开始反网络爬虫,想方设法保护自己的内容。他们根据ip访问频率，浏览网页速度，账户登录，输入验证码，flash封装，ajax混淆，js加密，图片，css混淆等五花八门的技术，来对反网络爬虫。防的一方不惜工本，迫使抓的一方在考虑成本效益后放弃抓的一方不惜工本，防的一方在考虑用户流失后放弃 #请求与响应 HTTP和HTTPS HTTP(HyperText Transfer Protocol，超文本传输协议)：是一种发布和接收HTML页面的方法 HTTPS(HyperText Transfer Protocol over Secure Socket Layer)简单讲是HTTP的安全版，在HTTP下加入SSL层。SSL(Secure Socket Layer安全套接层)主要用于web的安全传输协议，在传输层对网络连接进行加密，保障在Internet上数据传输的安全。 HTTP的端口号为80 HTTPS的端口号为443 http请求过程打开一个网站的时候，过程是这样的客户端（浏览器）发送请求到服务端（你打开的网站所在的服务器），服务端接收到请求，处理，返回数据给客户端（浏览器），然后咱们在浏览器里面看到了数据。 明白了这个过程之后呢，咱们再来说http请求里面都包含了什么东西。 请求方式主要有：GET/POST两种类型常用，另外还有HEAD/PUT/DELETE/OPTIONSGET和POST的区别就是：请求的数据GET是在url中，POST则是存放在请求体里面。 GET:一般向服务器获取数据用get请求，get请求的数据都是放在url中的，实质上和post请求没有太大的区别，当然也可以用来向服务器发送数据。 POST:一般向服务器发送数据用post请求，post请求的数据放在请求体里。 HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 PUT：向指定资源位置上传其最新内容。 OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 DELETE：请求服务器删除Request-URI所标识的资源。 请求urlURL，即统一资源定位符，也就是我们说的网址，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 URL的格式由三个部分组成：第一部分是协议(或称为服务方式)。 http/https第二部分是存有该资源的主机IP地址(有时也包括端口号)。 www.nnzhp.cn/192.168.1.1:8888第三部分是主机资源的具体地址，如目录和文件名等。 /index 爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据。 请求头一个请求由两部分组成， 请求头和请求体。 包含请求时的头部信息，如User-Agent,Host,Cookies等信息，user-agent就是你请求用的是什么浏览器，host就是服务端的地址，还有很多信息，服务端是如何分辨你是用的什么浏览器，你的ip地址就是从请求头里面获取到的。下面就是在请求我博客的时候，发送的头信息。 请求体请求体就是发送数据的时候，数据放在请求体里面。get请求是没有请求体的，从上面的截图也能看到，下面是没有这个请求体的。post请求才有请求体。下面的截图可以看到登陆的这个请求是一个post请求，登陆的账号密码就是放在请求体里面的。 http响应 发送了请求，服务端要返回数据。这个就是响应，请求是你发出去的，响应是服务端返回给你的。 响应包含了2个部分，一个是响应头，一个是响应体。响应头里面包含了响应的状态码，返回数据的类型，类型的长度，服务器信息，Cookie信息等等。 响应体里面就是具体返回的数据了。 响应状态码有很多响应状态，不同的状态码代表不同的状态，常见的状态码如：200代表成功，301跳转，404找不到页面，502服务端错误 1xx消息——请求已被服务器接收，继续处理 2xx成功——请求已成功被服务器接收、理解、并接受 3xx重定向——需要后续操作才能完成这一请求 4xx请求错误——请求含有词法错误或者无法被执行 5xx服务器错误——服务器在处理某个正确请求时发生错误 常见代码： 200 OK 请求成功 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 301 目标暂时性转移 302 目标永久性转移 响应头、响应体 看下图~ 代码示例12345678910111213import requests# 请求头header = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36&quot;&#125;发送get请求response = requests.get(&quot;http://www.xinhuanet.com/politics/2019-06/25/c_1124669748.htm&quot;, headers=header)response.encoding = &quot;utf-8&quot;写入文件with open(&quot;b.html&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(response.text)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫从零开始(五)]]></title>
    <url>%2F2019%2F06%2F25%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[Python 基础Python 输入输出读文件读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符： 1&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;r&apos;) 标示符’r’表示读，这样，我们就成功地打开了一个文件。 如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在： 1234&gt;&gt;&gt; f=open(&apos;/Users/michael/notfound.txt&apos;, &apos;r&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;FileNotFoundError: [Errno 2] No such file or directory: &apos;/Users/michael/notfound.txt&apos; 如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示： 12&gt;&gt;&gt; f.read()&apos;Hello, world!&apos; 最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的： 1&gt;&gt;&gt; f.close() 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现： 123456try: f = open(&apos;/path/to/file&apos;, &apos;r&apos;) print(f.read())finally: if f: f.close() 但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法： 12with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f: print(f.read()) 这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。 调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。 如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便： 123for line in f.readlines(): print(line.strip()) # 把末尾的&apos;\n&apos;删掉file-like Object 像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。 StringIO就是在内存中创建的file-like Object，常用作临时缓冲。 二进制文件前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用&#39;rb&#39;模式打开文件即可： 123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.jpg&apos;, &apos;rb&apos;)&gt;&gt;&gt; f.read()b&apos;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&apos; # 十六进制表示的字节 字符编码要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件： 123&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;)&gt;&gt;&gt; f.read()&apos;测试&apos; 遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略： 1&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;, errors=&apos;ignore&apos;) 写文件写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符&#39;w&#39;或者&#39;wb&#39;表示写文本文件或写二进制文件： 123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)&gt;&gt;&gt; f.close() 你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险： 12with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f: f.write(&apos;Hello, world!&apos;) 要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。 细心的童鞋会发现，以&#39;w&#39;模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入&#39;a&#39;以追加（append）模式写入。 所有模式的定义及含义可以参考Python的官方文档。 读写CSV文件csv文件的读取前期工作：在定义的py文件里边创建一个excel文件，并另存为csv文件，放入三行数据，我这里是姓名+年龄（可以自己随意写） 首先我们要在python环境里导入csv板块 12# -*- coding: utf-8 -*-import csv 然后我们定义一个csv文件的变量csv_file,然后通过open对此文件进行打开，打开模式采用‘r’（read：读模式） 12345with open(&quot;my.csv&quot;, &quot;r&quot;)as f: print(f) csv_file = csv.reader(f) for stu in csv_file: print(stu) 输出结果如下 1234&lt;_csv.reader object at 0x000001D3A1A1B730&gt;[&apos;zhangsan&apos;,&apos;32&apos;][&apos;wangwu&apos;,&apos;34&apos;][&apos;zhaoliu&apos;,&apos;35&apos;] csv文件的写入在开始前我们要定义两组数据，进行下面的写入 12stu1 = [&apos;marry&apos;,26]stu2 = [&apos;bob&apos;,23] 1.写入的第一步同样也是打开文件，因为我们是要写入，所以我们用的模式就是&#39;a&#39;模式，追加内容，至于&quot;newline=&quot;就是说因为我们的csv文件的类型，如果不加这个东西，当我们写入东西的时候，就会出现空行。 1out = open(&apos;Stu_csv.csv&apos;,&apos;a&apos;, newline=&apos;&apos;) 2.下面我们定义一个变量进行写入，将刚才的文件变量传进来，dialect就是定义一下文件的类型，我们定义为excel类型 1csv_write = csv.writer(out,dialect=&apos;excel&apos;) 3.然后进行数据的写入啦，写入的方法是writerow，通过写入模式对象，调用方法进行写入 12csv_write.writerow(stu1)csv_write.writerow(stu2) 4.最后各位可以用你们最熟悉的一句语法进行漂亮的收尾. 1print (&quot;write over&quot;) 具体的代码如下： 12345678910111213import csv#csv 写入stu1 = [&apos;marry&apos;,26]stu2 = [&apos;bob&apos;,23]#打开文件，追加aout = open(&apos;Stu_csv.csv&apos;,&apos;a&apos;, newline=&apos;&apos;)#设定写入模式csv_write = csv.writer(out,dialect=&apos;excel&apos;)#写入具体内容csv_write.writerow(stu1)csv_write.writerow(stu2)print (&quot;write over&quot;) mongoDB安装MongoDB首先到 MongoDB官网 下载安装MongoDB。并且到 MongoChef 官网下载安装可视化管理工具MongoChef studio3t 参考文件 安装PyMongo 驱动用可视化管理工具新建mydb数据库并添加student集合使用以下命令安装pymongo 驱动 1python -m pip install pymongo 也可以指定安装的版本: 1$ python -m pip install pymongo==3.5.1 更新 pymongo 命令： 1$ python -m pip install --upgrade pymongo 测试 PyMongo接下来我们可以创建一个测试文件 demo_test_mongodb.py，代码如下： demo_test_mongodb.py 文件代码： 123#!/usr/bin/python3 import pymongo 执行以上代码文件，如果没有出现错误，表示安装成功。 创建数据库创建一个数据库创建数据库需要使用 MongoClient 对象，并且指定连接的 URL 地址和要创建的数据库名。 如下实例中，我们创建的数据库 runoobdb : 实例 123456#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(&quot;mongodb://localhost:27017/&quot;)mydb = myclient[&quot;runoobdb&quot;] 注意: 在 MongoDB 中，数据库只有在内容插入后才会创建! 就是说，数据库创建后要创建集合(数据表)并插入一个文档(记录)，数据库才会真正创建。 判断数据库是否已存在我们可以读取 MongoDB 中的所有数据库，并判断指定的数据库是否存在： 实例 12345678910#!/usr/bin/python3 import pymongo myclient = pymongo.MongoClient(&apos;mongodb://localhost:27017/&apos;) dblist = myclient.list_database_names()# dblist = myclient.database_names() if &quot;runoobdb&quot; in dblist: print(&quot;数据库已存在！&quot;) 注意：database_names 在最新版本的 Python 中已废弃，Python3.7+ 之后的版本改为了 list_database_names()。 创建集合MongoDB 中的集合类似 SQL 的表。 创建一个集合MongoDB 使用数据库对象来创建集合，实例如下： 实例 1234567#!/usr/bin/python3import pymongo myclient = pymongo.MongoClient(&quot;mongodb://localhost:27017/&quot;)mydb = myclient[&quot;runoobdb&quot;] mycol = mydb[&quot;sites&quot;] 注意: 在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。 判断集合是否已存在我们可以读取 MongoDB 数据库中的所有集合，并判断指定的集合是否存在： 实例 12345678910#!/usr/bin/python3import pymongomyclient = pymongo.MongoClient(&apos;mongodb://localhost:27017/&apos;)mydb = myclient[&apos;runoobdb&apos;]collist = mydb. list_collection_names()# collist = mydb.collection_names()if &quot;sites&quot; in collist: # 判断 sites 集合是否存在 print(&quot;集合已存在！&quot;) 添加文档操作123456789101112131415161718from pymongo import MongoClient# 连接服务器conn = MongoClient(&quot;localhost&quot;, 27017)# 连接数据库db = conn.mydb# 获取集合collection = db.student# 添加文档# collection.insert(&#123;&quot;name&quot;:&quot;abc&quot;, &quot;age&quot;:19, &quot;gender&quot;:1,&quot;address&quot;:&quot;北京&quot;, &quot;isDelete&quot;:0&#125;)collection.insert_many([&#123;&quot;name&quot;: &quot;abc1&quot;, &quot;age&quot;: 19, &quot;gender&quot;: 1, &quot;address&quot;: &quot;北京&quot;, &quot;isDelete&quot;: 0&#125;, &#123;&quot;name&quot;: &quot;abc2&quot;, &quot;age&quot;: 19, &quot;gender&quot;: 1, &quot;address&quot;: &quot;北京&quot;, &quot;isDelete&quot;: 0&#125;])# 断开conn.close() 查询文档操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import pymongofrom pymongo import MongoClientfrom bson.objectid import ObjectId # 用于ID查询# 连接服务器conn = MongoClient(&quot;localhost&quot;, 27017)# 连接数据库db = conn.mydb# 获取集合collection = db.student# 查询文档# 查询部分文档&apos;&apos;&apos;res = collection.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:18&#125;&#125;)for row in res: print(row) print(type(row))&apos;&apos;&apos;# 查询所有文档&apos;&apos;&apos;res = collection.find()for row in res: print(row) print(type(row))&apos;&apos;&apos;# 统计查询&apos;&apos;&apos;res = collection.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:18&#125;&#125;).count()print(res)&apos;&apos;&apos;# 根据id查询&apos;&apos;&apos;res = collection.find(&#123;&quot;_id&quot;:ObjectId(&quot;5995084b019723fe2a0d8d14&quot;)&#125;)print(res[0])&apos;&apos;&apos;# 排序&apos;&apos;&apos;# res = collection.find().sort(&quot;age&quot;)#升序res = collection.find().sort(&quot;age&quot;, pymongo.DESCENDING)for row in res: print(row)&apos;&apos;&apos;# 分页查询res = collection.find().skip(3).limit(5)for row in res: print(row)# 断开conn.close() 更新文档操作12345678910111213from pymongo import MongoClient# 连接服务器conn = MongoClient(&quot;localhost&quot;, 27017)# 连接数据库db = conn.mydb# 获取集合collection = db.studentcollection.update(&#123;&quot;name&quot;: &quot;lilei&quot;&#125;, &#123;&quot;$set&quot;: &#123;&quot;age&quot;: 25&#125;&#125;)# 断开conn.close() 删除文档操作1234567891011121314from pymongo import MongoClient# 连接服务器conn = MongoClient(&quot;localhost&quot;, 27017)# 连接数据库db = conn.mydb# 获取集合collection = db.studentcollection.remove(&#123;&quot;name&quot;: &quot;lilei&quot;&#125;)# 全部删除collection.remove()# 断开conn.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫从零开始(四)]]></title>
    <url>%2F2019%2F06%2F24%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Python 基础面向对象面向对象（Object Oriented）的英文缩写是OO，它是一种设计思想。我们经常听说的面向对象编程（Object Oriented Programming，即OOP）就是主要针对大型软件设计而提出的，它可以使软件设计更加灵活，并且能更好地进行代码复用。 面向对象中的对象（Object），通常是指客观世界中存在的对象，这个对象具有唯一性，对象之间个不相同，各有各的特点，每一个对象都有自己的运动规律和内部状态；对象和对象之间又是可以相互联系、相互作用的。 对象：是一个抽象概念，英文称为Object，表示任意存在的事物。世间万物皆对象，现实世间中随处可以的一种事物就是对象，对象是事物存在的实体，如一个人。 通常将对象划分为两个部分：静态部分和动态部分。静态部分被称为【属性】，任何对象都具备自身属性，这些属性不仅是客观存在的，而且是不能被忽视的。如人的性别。动态部分指的是对象的行为，即对象执行的动作，如人可以行走。 类和实例面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 代码示例 1234567class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print(&apos;%s: %s&apos; % (self.name, self.score)) 通过class关键字来定义类，类名通常要大写，后面的括号里面表示该类继承于哪个类，所有类最终继承于object类，这类似于Java python允许对实例变量绑定任何数据，因此同一个类的不同实例拥有的变量名称可能会不同 特殊的__init__方法可以把必须绑定给类实例的属性填写进去，它的第一个参数永远是self，表示创建的实例本身，在创建实例的时候，必须传入与init方法匹配的参数，self除外 实际上，Python中类中定义的函数的第一个参数都必须是self，调用时不用传递该参数对Student类使用实例代码： 12345678chen = Student(&apos;chen&apos;, 13)bart = Student(&apos;bart&apos;, 81)chen.print_score()bart.print_score()chen.score = 100bart.name = &apos;kobe&apos;chen.print_score()bart.print_score() 输出结果 1234chen: 13bart: 81chen: 100kobe: 81 访问限制 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问:1234567891011121314class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print(&apos;%s: %s&apos; % (self.__name, self.__score))&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)&gt;&gt;&gt; bart.__nameTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Student&apos; object has no attribute &apos;__name&apos; 这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。 但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法： 12345678class Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score 如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法： 12345class Student(object): ... def set_score(self, score): self.__score = score 你也许会问，原先那种直接通过bart.score = 99也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数： 12345678class Student(object): ... def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError(&apos;bad score&apos;) 需要注意的是，在Python中，变量名类似xxx的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用name、score这样的变量名。以一个下划线开头的变量_name外部可以访问，但是最好把它视为私有变量，不要随便访问python解释器对外把__name改成了_Student__name，因此可以通过_Student__name来访问私有的内部属性(强烈建议不要采用这种方式)： 12&gt;&gt;&gt; bart._Student__name&apos;Bart Simpson&apos; 我们在前面发现无法输出bart.__name，会报错Student类不含有此成员，但是bart.__name = &#39;New Name&#39;语 句是不会报错的，随后再输出bart.__name也不会再报错了： 123456&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)&gt;&gt;&gt; bart.get_name()&apos;Bart Simpson&apos;&gt;&gt;&gt; bart.__name = &apos;New Name&apos; # 设置__name变量！&gt;&gt;&gt; bart.__name&apos;New Name&apos; 这是一种错误的写法，这样设置的__name变量并不是类内部的__name变量，相当于给bart新增了一个变量 继承和多态在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。 比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印： 123class Animal(object): def run(self): print(&apos;Animal is running...&apos;) 当我们需要编写Dog和Cat类时，就可以直接从Animal类继承： 1234class Dog(Animal): passclass Cat(Animal): pass 对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。 继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法： 12345dog = Dog()dog.run()cat = Cat()cat.run() 运行结果如下： 12Animal is running...Animal is running... 当然，也可以对子类增加一些方法，比如Dog类： 1234567class Dog(Animal): def run(self): print(&apos;Dog is running...&apos;) def eat(self): print(&apos;Eating meat...&apos;) 继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running...，符合逻辑的做法是分别显示Dog is running...和Cat is running...，因此，对Dog和Cat类改进如下： 123456789class Dog(Animal): def run(self): print(&apos;Dog is running...&apos;)class Cat(Animal): def run(self): print(&apos;Cat is running...&apos;) 再次运行，结果如下： 12Dog is running...Cat is running... 当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。 要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样： 123a = list() # a是list类型b = Animal() # b是Animal类型c = Dog() # c是Dog类型 判断一个变量是否是某个类型可以用isinstance()判断： 123456&gt;&gt;&gt; isinstance(a, list)True&gt;&gt;&gt; isinstance(b, Animal)True&gt;&gt;&gt; isinstance(c, Dog)True 看来a、b、c确实对应着list、Animal、Dog这3种类型。 但是等等，试试： 12&gt;&gt;&gt; isinstance(c, Animal)True 看来c不仅仅是Dog，c还是Animal！ 不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种！ 所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行： 123&gt;&gt;&gt; b = Animal()&gt;&gt;&gt; isinstance(b, Dog)False Dog可以看成Animal，但Animal不可以看成Dog。 要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量： 123def run_twice(animal): animal.run() animal.run() 当我们传入Animal的实例时，run_twice()就打印出： 123&gt;&gt;&gt; run_twice(Animal())Animal is running...Animal is running... 当我们传入Dog的实例时，run_twice()就打印出： 123&gt;&gt;&gt; run_twice(Dog())Dog is running...Dog is running... 当我们传入Cat的实例时，run_twice()就打印出： 123&gt;&gt;&gt; run_twice(Cat())Cat is running...Cat is running... 看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生： 123class Tortoise(Animal): def run(self): print(&apos;Tortoise is running slowly...&apos;) 当我们调用run_twice()时，传入Tortoise的实例： 123&gt;&gt;&gt; run_twice(Tortoise())Tortoise is running slowly...Tortoise is running slowly... 你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思： 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则： 对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树： 1234567891011121314151617 ┌───────────────┐ │ object │ └───────────────┘ │ ┌────────────┴────────────┐ │ │ ▼ ▼ ┌─────────────┐ ┌─────────────┐ │ Animal │ │ Plant │ └─────────────┘ └─────────────┘ │ │ ┌─────┴──────┐ ┌─────┴──────┐ │ │ │ │ ▼ ▼ ▼ ▼┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐│ Dog │ │ Cat │ │ Tree │ │ Flower │└─────────┘ └─────────┘ └─────────┘ └─────────┘ 获取对象信息使用type()来判断对象类型，它返回对应的Class类型。基本类型可以使用type()来判断： 12345678&gt;&gt;&gt; type(123)&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; type(2.0)&lt;class &apos;float&apos;&gt;&gt;&gt;&gt; type([&quot;sd&quot;,&apos;s&apos;,12])&lt;class &apos;list&apos;&gt;&gt;&gt;&gt; type(None)&lt;class &apos;NoneType&apos;&gt; 函数和类也可以使用type()来判断： 1234567891011&gt;&gt;&gt; class Person:... pass... &gt;&gt;&gt; def test():... pass... &gt;&gt;&gt; p = Person()&gt;&gt;&gt; type(p)&lt;class &apos;__main__.Person&apos;&gt;&gt;&gt;&gt; type(test)&lt;class &apos;function&apos;&gt; 利用type来作为if的判断条件，当类型不是int,str等基本类型时，需要使用types模块中定义的常量： 123456789101112&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():... pass...&gt;&gt;&gt; type(fn)==types.FunctionTypeTrue&gt;&gt;&gt; type(abs)==types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x: x)==types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorTypeTrue 使用isinstance()来判断对象是否是某种类型isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上 能用type()判断的基本类型也可以用isinstance()判断: 123456&gt;&gt;&gt; isinstance(&apos;a&apos;, str)True&gt;&gt;&gt; isinstance(123, int)True&gt;&gt;&gt; isinstance(b&apos;a&apos;, bytes)True isinstance不仅可以判断是否是某种类型，还可以判断是否是某些类型的一种： 1234&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True 使用dir()来获得一个对象的所有属性和方法获取str的所有属性和方法： 12&gt;&gt;&gt; dir(&apos;ABC&apos;)[&apos;__add__&apos;, &apos;__class__&apos;,..., &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;,..., &apos;zfill&apos;] 利用getattr()、setattr()以及hasattr()，我们可以直接操作一个对象,不过这几个函数是在不知道对象信息的时候使用的，在了解对象信息时没有必要使用: 123456789101112131415161718192021&gt;&gt;&gt; class MyObject(object):... def __init__(self):... self.x = 9... def power(self):... return self.x * self.x...&gt;&gt;&gt; obj = MyObject()&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？False&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？True&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;19&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;19 对于getattr()函数，可以在传入的属性参数后面加一个默认的参数，这样在对象不含有这个属性时就会返回默认参数，而不是抛出异常了： 123# 获取属性&apos;z&apos;，如果不存在，返回默认值404&gt;&gt;&gt; getattr(obj, &apos;z&apos;, 404) 404 getattr()函数还可以用于获取方法，把获取的方法赋值给一个变量，那个变量就指向这个方法，调用那个变量就相当于调用了这个方法： 1234567&gt;&gt;&gt; getattr(obj, &apos;power&apos;) # 获取属性&apos;power&apos;&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, &apos;power&apos;) # 获取属性&apos;power&apos;并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81 实例属性和类属性实例属性我们在之前就已经使用过了，我们也了解到在python中可以给一个类实例绑定任何属性，方法是在类方法中利用self或者直接通过实例来绑定。 要给类绑定一个属性的话，可以在类中直接定义它： 12class Student(object): name = &apos;Student&apos; 也可以把类属性成为类的静态成员变量，这个属性是归类所有的，所有实例可以共享它。需要注意的是，虽然name属性归类Student所有，但是类的所有实例都可以访问到，并且实例属性的优先级比类属性高，所以如果实例绑定了一个与类属性同名的实例属性时，优先调用的是实例属性： 12345678910111213141516&gt;&gt;&gt; class Student(object):... name = &apos;Student&apos;...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student 异常处理异常处理捕捉异常可以使用try/except语句。 try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。 如果你不想在异常发生时结束你的程序，只需在try里捕获它。 语法： 以下为简单的try....except...else的语法： 12345678try:&lt;语句&gt; #运行别的代码except &lt;名字&gt;：&lt;语句&gt; #如果在try部份引发了&apos;name&apos;异常except &lt;名字&gt;，&lt;数据&gt;:&lt;语句&gt; #如果引发了&apos;name&apos;异常，获得附加的数据else:&lt;语句&gt; #如果没有异常发生 try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。 如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。 如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印缺省的出错信息）。 如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。 实例 下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，且并未发生异常： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(&quot;testfile&quot;, &quot;w&quot;) fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)except IOError: print &quot;Error: 没有找到文件或读取文件失败&quot;else: print &quot;内容写入文件成功&quot; fh.close() 以上程序输出结果： 1234$ python test.py 内容写入文件成功$ cat testfile # 查看写入的内容这是一个测试文件，用于测试异常!! 实例 下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，但文件没有写入权限，发生了异常： 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(&quot;testfile&quot;, &quot;w&quot;) fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)except IOError: print &quot;Error: 没有找到文件或读取文件失败&quot;else: print &quot;内容写入文件成功&quot; fh.close() 在执行代码前为了测试方便，我们可以先去掉 testfile 文件的写权限，命令如下： 1chmod -w testfile 再执行以上代码： 12$ python test.py Error: 没有找到文件或读取文件失败 使用except而不带任何异常类型你可以不带任何异常类型使用except，如下实例： 12345678try: 正常的操作 ......................except: 发生异常，执行这块代码 ......................else: 如果没有异常执行这块代码 以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。 使用except而带多种异常类型你也可以使用相同的except语句来处理多个异常信息，如下所示： 12345678try: 正常的操作 ......................except(Exception1[, Exception2[,...ExceptionN]]]): 发生以上多个异常中的一个，执行这块代码 ......................else: 如果没有异常执行这块代码 try-finally 语句try-finally 语句无论是否发生异常都将执行最后的代码。 12345try:&lt;语句&gt;finally:&lt;语句&gt; #退出try时总会执行raise 实例 12345678#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(&quot;testfile&quot;, &quot;w&quot;) fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)finally: print &quot;Error: 没有找到文件或读取文件失败&quot; 如果打开的文件没有可写权限，输出如下所示： 12$ python test.py Error: 没有找到文件或读取文件失败 同样的例子也可以写成如下方式： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*-try: fh = open(&quot;testfile&quot;, &quot;w&quot;) try: fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;) finally: print &quot;关闭文件&quot; fh.close()except IOError: print &quot;Error: 没有找到文件或读取文件失败&quot; 当在try块中抛出一个异常，立即执行finally块代码。 finally块中的所有语句执行后，异常被再次触发，并执行except块代码。 参数的内容不同于异常。 异常的参数一个异常可以带上参数，可作为输出的异常信息参数。 你可以通过except语句来捕获异常的参数，如下所示： 12345try: 正常的操作 ......................except ExceptionType, Argument: 你可以在这输出 Argument 的值... 变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。 元组通常包含错误字符串，错误数字，错误位置。 实例以下为单个异常的实例： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*-# 定义函数def temp_convert(var): try: return int(var) except ValueError, Argument: print &quot;参数没有包含数字\n&quot;, Argument# 调用函数temp_convert(&quot;xyz&quot;); 以上程序执行结果如下： 123$ python test.py 参数没有包含数字invalid literal for int() with base 10: &apos;xyz&apos; 触发异常我们可以使用raise语句自己触发异常 raise语法格式如下： 1raise [Exception [, args [, traceback]]] 语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。 最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。 实例一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。 定义一个异常非常简单，如下所示： 1234def functionName( level ): if level &lt; 1: raise Exception(&quot;Invalid level!&quot;, level) # 触发异常后，后面的代码就不会再执行 注意：为了能够捕获异常，”except“语句必须有用相同的异常来抛出类对象或者字符串。 例如我们捕获以上异常，”except“语句如下所示： 123456try: 正常逻辑except Exception,err: 触发自定义异常 else: 其余代码 实例 1234567891011121314#!/usr/bin/python# -*- coding: UTF-8 -*-# 定义函数def mye( level ): if level &lt; 1: raise Exception,&quot;Invalid level!&quot; # 触发异常后，后面的代码就不会再执行try: mye(0) # 触发异常except Exception,err: print 1,errelse: print 2 执行以上代码，输出结果为： 12$ python test.py 1 Invalid level! 用户自定义异常通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。 以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。 在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。 123class Networkerror(RuntimeError): def __init__(self, arg): self.args = arg 在你定义以上类后，你可以触发该异常，如下所示： 1234try: raise Networkerror(&quot;Bad hostname&quot;)except Networkerror,e: print e.args]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫从零开始(三)]]></title>
    <url>%2F2019%2F06%2F23%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Python 基础函数定义函数在Python中定义函数需要使用def语句，接着是函数名、左括号、参数、右括号、冒号：，在缩进块中编写函数体，返回值使用return语句返回。例子：定义my_fun 1234567def my_fun(): print(&quot;Hello World!&quot;)my_fun()#结果 输出Hello World! 函数调用定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。 这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。 如下实例调用了 printme() 函数： 123456789# 定义函数def printme( str ): # 打印任何传入的字符串 print (str) return # 调用函数printme(&quot;我要调用用户自定义函数!&quot;)printme(&quot;再次调用同一函数&quot;) 以上实例输出结果： 12我要调用用户自定义函数!再次调用同一函数 参数传递在 python 中，类型属于对象，变量是没有类型的： 12a=[1,2,3]a=&quot;Runoob&quot; 以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 python 传不可变对象实例123456def ChangeInt( a ): a = 10 b = 2ChangeInt(b)print( b ) # 结果是 2 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 传递可变对象实例可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如： 1234567891011# 可写函数说明def changeme( mylist ): &quot;修改传入的列表&quot; mylist.append([1,2,3,4]) print (&quot;函数内取值: &quot;, mylist) return # 调用changeme函数mylist = [10,20,30]changeme( mylist )print (&quot;函数外取值: &quot;, mylist) 传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下： 12函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数以下是调用函数时可使用的正式参数类型： 必需参数 关键字参数 默认参数 不定长参数 必需参数必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 调用 printme() 函数，你必须传入一个参数，不然会出现语法错误： 实例 12345678#可写函数说明def printme( str ): &quot;打印任何传入的字符串&quot; print (str) return # 调用 printme 函数，不加参数会报错printme() 以上实例输出结果： 1234Traceback (most recent call last): File &quot;test.py&quot;, line 10, in &lt;module&gt; printme()TypeError: printme() missing 1 required positional argument: &apos;str&apos; 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 以下实例在函数 printme() 调用时使用参数名： 实例 12345678#可写函数说明def printme( str ): &quot;打印任何传入的字符串&quot; print (str) return #调用printme函数printme( str = &quot;elichen&quot;) 以上实例输出结果： 1elichen 以下实例中演示了函数参数的使用不需要使用指定顺序： 123456789#可写函数说明def printinfo( name, age ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return #调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; ) 以上实例输出结果： 12名字: runoob年龄: 50 默认参数调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值： 实例 1234567891011#可写函数说明def printinfo( name, age = 35 ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return #调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; )print (&quot;------------------------&quot;)printinfo( name=&quot;runoob&quot; ) 以上实例输出结果： 12345名字: runoob年龄: 50------------------------名字: runoob年龄: 35 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下： 1234def functionname([formal_args,] *var_args_tuple ): &quot;函数_文档字符串&quot; function_suite return [expression] 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 实例 123456789# 可写函数说明def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vartuple) # 调用printinfo 函数printinfo( 70, 60, 50 ) 以上实例输出结果： 123输出: 70(60, 50) 如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例： 123456789101112# 可写函数说明def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) for var in vartuple: print (var) return # 调用printinfo 函数printinfo( 10 )printinfo( 70, 60, 50 ) 以上实例输出结果： 123456输出:10输出:706050 还有一种就是参数带两个星号 **基本语法如下： 1234def functionname([formal_args,] **var_args_dict ): &quot;函数_文档字符串&quot; function_suite return [expression] 加了两个星号 ** 的参数会以字典的形式导入。 123456789# 可写函数说明def printinfo( arg1, **vardict ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vardict) # 调用printinfo 函数printinfo(1, a=2,b=3) 以上实例输出结果： 123输出: 1&#123;&apos;a&apos;: 2, &apos;b&apos;: 3&#125; 声明函数时，参数中星号 * 可以单独出现，例如: 12def f(a,b,*,c): return a+b+c 如果单独出现星号 * 后的参数必须用关键字传入。 12345678910&gt;&gt;&gt; def f(a,b,*,c):... return a+b+c... &gt;&gt;&gt; f(1,2,3) # 报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: f() takes 2 positional arguments but 3 were given&gt;&gt;&gt; f(1,2,c=3) # 正常6&gt;&gt;&gt; 模块Python3模块在前面的几个章节中我们脚本上是用 python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。 为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。 模块是一个包含所有你定义的函数和变量的文件，其后缀名是 .py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。 下面是一个使用 python 标准库中模块的例子。 1234567import sys print(&apos;命令行参数如下:&apos;)for i in sys.argv: print(i) print(&apos;\n\nPython 路径为：&apos;, sys.path, &apos;\n&apos;) 执行结果如下所示： 12345678$ python using_sys.py 参数1 参数2命令行参数如下:using_sys.py参数1参数2Python 路径为： [&apos;/root&apos;, &apos;/usr/lib/python3.4&apos;, &apos;/usr/lib/python3.4/plat-x86_64-linux-gnu&apos;, &apos;/usr/lib/python3.4/lib-dynload&apos;, &apos;/usr/local/lib/python3.4/dist-packages&apos;, &apos;/usr/lib/python3/dist-packages&apos;] 1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。 2、sys.argv 是一个包含命令行参数的列表。 3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。导入模块语句想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：1import module1[, module2[,... moduleN] Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下： 1from modname import name1[, name2[, ... nameN]] 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： 1from modname import *]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫从零开始(二)]]></title>
    <url>%2F2019%2F06%2F22%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Python 基础基本数据类型Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。 123a = 100 #整型变量b = 100.1 #浮点型变量c = &quot;elichen&quot; #字符型 Python允许多个变量同时赋值例如 1a = b = c = 1 你也可以为多个对象指定多个变量 1a, b, c = 1, 2, &quot;elichen&quot; 标准数据类型Python3 中有六个标准数据类型： Number （数字） String （字符串） List （列表） Tuple （元组） Set （集合） Dictionary（字典） Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 1、Number（数字）Python3 支持 int、float、bool、complex（复数） 关于布尔类型： Python3中，把True和False定义成关键字，他们的值是1和0，它们可以和数字相加。 在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 像大多数语言一样，数值类型的赋值和计算都是很直观的。 内置的 type() 函数可以用来查询变量所指的对象类型。 此外还可以用 isinstance 来判断： 123a = 1isinstance(a, int)# 结果为True isinstance 和 type 的区别在于： type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 当你指定一个值时，Number 对象就会被创建： 12var1 = 1var2 = 10 你也可以使用del语句删除一些对象引用。 del语句的语法是： 1del var1[,var2[,var3[....,varN]]] 您可以通过使用del语句删除单个或多个对象。例如: 12del vardel var_a, var_b 数值运算 1234567891011121314&gt;&gt;&gt;5 + 4 # 加法9&gt;&gt;&gt; 4.3 - 2 # 减法2.3&gt;&gt;&gt; 3 * 7 # 乘法21&gt;&gt;&gt; 2 / 4 # 除法，得到一个浮点数0.5&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数0&gt;&gt;&gt; 17 % 3 # 取余 2&gt;&gt;&gt; 2 ** 5 # 乘方32 2、String（字符串）Python中的字符串用单引号(‘)或双引号(“)括起来，同时使用反斜杠()转义特殊字符。 字符串的截取的语法格式如下： 变量[头下标:尾下标] 加号 + 是字符串的连接符， 星号 * 表示复制当前字符串，紧跟的数字为复制的次数。实例如下： 123456789str = &apos;Elichen&apos; print (str) # 输出字符串print (str[0:-1]) # 输出第一个到倒数第二个的所有字符print (str[0]) # 输出字符串第一个字符print (str[2:5]) # 输出从第三个开始到第五个的字符print (str[2:]) # 输出从第三个开始的后的所有字符print (str * 2) # 输出字符串两次print (str + &quot;TEST&quot;) # 连接字符串 执行以上程序会输出如下结果： 1234567ElichenElicheEichichenElichenElichenElichenTEST Python 使用反斜杠()转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串： 123456&gt;&gt;&gt; print(&apos;Ru\noob&apos;)Ruoob&gt;&gt;&gt; print(r&apos;Ru\noob&apos;)Ru\noob&gt;&gt;&gt; 3、List（列表）List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 列表截取的语法格式如下： 变量[头下标:尾下标] 加号 + 是列表连接运算符，星号 * 是重复操作。如下实例： 123456789list = [&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2]tinylist = [123, &apos;elichen&apos;]print(list) # 输出完整列表print(list[0]) # 输出列表第一个元素print(list[1:3]) # 从第二个开始输出到第三个元素print(list[2:]) # 输出从第三个元素开始的所有元素print(tinylist * 2) # 输出两次列表print(list + tinylist) # 连接列表 以上实例输出结果： 123456[&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2]abcd[786, 2.23][2.23, &apos;elichen&apos;, 70.2][123, &apos;elichen&apos;, 123, &apos;elichen&apos;][&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2, 123, &apos;elichen&apos;] 与Python字符串不一样的是，列表中的元素是可以改变的： 12345678&gt;&gt;&gt;a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; a[0] = 9&gt;&gt;&gt; a[2:5] = [13, 14, 15]&gt;&gt;&gt; a[9, 2, 13, 14, 15, 6]&gt;&gt;&gt; a[2:5] = [] # 将对应的元素值设置为 [] &gt;&gt;&gt; a[9, 2, 6] List写在方括号之间，元素用逗号隔开。 和字符串一样，list可以被索引和切片。 List可以使用+操作符进行拼接。 List中的元素是可以改变的。 Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： 123list1 = [&apos;e&apos;, &apos;l&apos;, &apos;i&apos;, &apos;c&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;]print(list1[1:4:2])# 结果为 [&apos;l&apos;, &apos;c&apos;] 4、Tuple（元组）语法：(,,,)。使用()标识，元素之间用逗号分隔。 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。 元组中的元素类型也可以不相同； 123456789tuple = (&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2)tinytuple = (123, &apos;elichen&apos;)print(tuple) # 输出完整元组print(tuple[0]) # 输出元组的第一个元素print(tuple[1:3]) # 输出从第二个元素开始到第三个元素print(tuple[2:]) # 输出从第三个元素开始的所有元素print(tinytuple * 2) # 输出两次元组print(tuple + tinytuple) # 连接元组 以上实例输出结果： 123456(&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2)abcd(786, 2.23)(2.23, &apos;elichen&apos;, 70.2)(123, &apos;elichen&apos;, 123, &apos;elichen&apos;)(&apos;abcd&apos;, 786, 2.23, &apos;elichen&apos;, 70.2, 123, &apos;elichen&apos;) 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则： 12tup1 = () # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号 string、list 和 tuple 都属于 sequence（序列）。 注意： 1、与字符串一样，元组的元素不能修改。 2、元组也可以被索引和切片，方法一样。 3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。 4、元组也可以使用+操作符进行拼接。 5、Set（集合）集合（set）是一个无序不重复元素的序列。创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 创建格式： 123parame = &#123;value01,value02,...&#125;或者set(value) 实例 12345678910111213141516171819student = &#123;&apos;Tom&apos;, &apos;Jim&apos;, &apos;Mary&apos;, &apos;Tom&apos;, &apos;Jack&apos;, &apos;Rose&apos;&#125; print(student) # 输出集合，重复的元素被自动去掉 # 成员测试if &apos;Rose&apos; in student : print(&apos;Rose 在集合中&apos;)else : print(&apos;Rose 不在集合中&apos;)# set可以进行集合运算a = set(&apos;abracadabra&apos;)b = set(&apos;alacazam&apos;) print(a)print(a - b) # a 和 b 的差集print(a | b) # a 和 b 的并集print(a &amp; b) # a 和 b 的交集print(a ^ b) # a 和 b 中不同时存在的元素 以上实例输出结果： 1234567&#123;&apos;Mary&apos;, &apos;Jim&apos;, &apos;Rose&apos;, &apos;Jack&apos;, &apos;Tom&apos;&#125;Rose 在集合中&#123;&apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;r&apos;, &apos;d&apos;&#125;&#123;&apos;b&apos;, &apos;d&apos;, &apos;r&apos;&#125;&#123;&apos;l&apos;, &apos;r&apos;, &apos;a&apos;, &apos;c&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;&#125;&#123;&apos;a&apos;, &apos;c&apos;&#125;&#123;&apos;l&apos;, &apos;r&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;&#125; 6、Dictionary（字典）字典是一种映射类型，字典用{ }标识，它是一个无序的键(key) : 值(value)对集合。 字典（dictionary）是Python中另一个非常有用的内置数据类型，键(key)必须使用不可变类型，键(key)必须是唯一的。 123456789101112dict = &#123;&#125;dict[&apos;one&apos;] = &quot;1&quot;dict[2] = &quot;2&quot; tinydict = &#123;&apos;name&apos;: &apos;elichen&apos;,&apos;code&apos;:1, &apos;site&apos;: &apos;www.elichen.club&apos;&#125; print (dict[&apos;one&apos;]) # 输出键为 &apos;one&apos; 的值print (dict[2]) # 输出键为 2 的值print (tinydict) # 输出完整的字典print (tinydict.keys()) # 输出所有键print (tinydict.values()) # 输出所有值 以上实例输出结果： 1234512&#123;&apos;name&apos;: &apos;elichen&apos;, &apos;code&apos;: 1, &apos;site&apos;: &apos;www.elichen.club&apos;&#125;dict_keys([&apos;name&apos;, &apos;code&apos;, &apos;site&apos;])dict_values([&apos;elichen&apos;, 1, &apos;www.elichen.club&apos;]) 注意： 1、字典是一种映射类型，它的元素是键值对。 2、字典的关键字必须为不可变类型，且不能重复。 3、创建空字典使用 { }。 Python数据类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。 函数 描述 int(x [,base]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫从零开始(一)]]></title>
    <url>%2F2019%2F06%2F21%2FPython%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[（一） Python环境搭建第一步:Python安装包下载首先从 Python官网 下载Python安装程序，注意32位和64位的区别，如果你的电脑是32位的请选择32位的安装包，如果你的电脑是64位的请选择64位的安装包。 第二步:安装双击下载好的Python安装包。 勾选添加Python到环境变量，选择默认安装或者自定义安装，如果忘记打勾，则需要手工加到环境变量中；在这里我选择的是自定义安装，点击“自定义安装”进行下一步操作； 进入到下一步后，选择需要安装的组件，然后点击下一步: 在这里可以自定义路径选择安装： 点击下一步后，就开始真正安装了，安装完成后点击关闭即可。 第三步: 测试python安装好之后，我们要检测一下是否安装成功，用系统管理员打开命令行工具cmd，输入“python”,然后敲回车，如果出现如下界面，则表示我们安装成功了； 如果不显示版本号，提示‘python’ 不是内部或外部命令，也不是可运行的程序或批处理文件，则需要手动将python.exe所在的目录添加到环境变量PATH中。 （二）pycharm的安装与配置第一步:下载pycharm点击 pycharm官网 进入pycharm 官网下载免费的Community版本 第二步:安装pycharm双击下载的安装包,出现如下界面点击next 可以选择安装位置，继续点击next 勾选以下选项，点击next 点击install 第三步:pycharm的入门基础配置安装完成打开pycharm显示如下，因为之前安装过所以会让我当如配置文件，没安装过的选择不导入设置，点击OK。 同意协议点击继续 选择喜欢的主题 选择你要安装的插件继续 打开设置 展开editor 双击Font 设置你喜欢的字体样式和大小 第四步:pycharm的Python解释器的搭建 完成如下操作点击OK。 点击OK完成设置 更新Python解释器 完成后就可以新建工程愉快的写代码了。 第五步:pycharm的建立一个新项目点击create New Project 选择项目路径 选择项目解释器，选择刚刚设置的Python解释器 点击create 项目目录右键点击选择new 选择 Python File 给文件起个名字点击OK 写入代码右键单击编辑区选择Run 输出结果 大功告成! 至此，pycharm已经全部安装完成。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[happybirthday]]></title>
    <url>%2F2019%2F04%2F18%2F%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX18xKGftPCrfDzAPJAYiwCMaSZ3OKXR0eElT9iiBavlB+G0EjrcHXN5NI0m8eHXNNEmR9aBA7SsmwN1r69JJRKYZzTSqwgtCtLxVJdK9FvJyI5eyWGhm45BApiCL+W6Pw9R3xqH/zI0fhGxfVfjjep8wYe2eUmORhcLzOX5di8Je0B3PUs6r91jb var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[给🐖的信]]></title>
    <url>%2F2019%2F03%2F30%2F%E4%B8%80%E5%91%A8%E5%B9%B4%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19B4ilcVqNhCvh2Jl2EBIAkuj7z9lm1qejLEPZi8F5gXPQH/WJ4tRuVNq3xpwl4LH3JJOWj0Fuuw6zDrSn/qXW7kwiKTq/qGj2WoDikziltb293Gm/aAgPe/oYftIvMLFYMU4yUOfbSACdlXktsNiTsrGmEA21NaZbM47LGvaZPdNZt6P+U0ZSL var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
  </entry>
</search>
